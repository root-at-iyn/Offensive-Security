# Shellcoding - Level 2

## Mission (Hackerproof Cowsay)

Using your last exploit, we managed to get a foothold in their network! Unfortunately, our operations guys got caught pretty quickly, and the target organization pushed up a patched version of cowsay that breaks your exploit!

Can you take a look at this one? It has some hacker-detection built in, but we're sure you're up to the challenge!!


## Source Code

```c
// gcc -g -I ../includes -z execstack -fno-stack-protector -no-pie -o 04_level_2 04_level_2.c
#include <stdio.h>
#include <string.h>

// Hidden for simplicity
#include "wargames.h"
#include "visualize.h"

int check_for_hacks(const char * buffer)
{
    size_t len = strlen(buffer);
    for (int i = 0; i < len; i++)
    {
        // Hackers seem to use these a lot hmm
        if (buffer[i] == 0x3b ||
                buffer[i] == '/' ||
                buffer[i] == 'b' ||
                buffer[i] == 'i' ||
                buffer[i] == 'n' ||
                buffer[i] == 's' ||
                buffer[i] == 'h')
            return 0;
    }

    // Buffer is OK
    return 1;
}

void cowsay(const char * text)
{
    // Print top of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print speech text
    printf("   < %s >\n", text);

    // Print bottom of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print an ASCII cow
    printf("           \\   ^__^             \n");
    printf("            \\  (oo)\\_______     \n");
    printf("               (__)\\       )\\/\\ \n");
    printf("                   ||----w |    \n");
    printf("                   ||     ||     \n");
    printf("        .--+--o--------+------\\+/-----.\n");
}

void main()
{
    init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Shellcode Level #2 - Cowsay v2.0                        \n");
    printf("------------------------------------------------------------\n");

    // Buffer to hold user input & final cowsay text
    char text[128] = {};
    char buffer[128] = {};

    // Prompt the user for some cow-friendly text
    printf("Enter a string to cowsay: ");
    fgets(buffer, sizeof(buffer), stdin);
    buffer[strcspn(buffer, "\n")] = 0;

    // Build the final cowsay message, with some added mooing
    strcat(text, "mo00oooo00o0o... ");
    strcat(text, buffer);

    // Clear the original user input buffer off the stack
    memset(buffer, 0, sizeof(buffer));

    // Validate the text before printing it, to ensure no funny-business
    if (check_for_hacks(text)) {
        cowsay(text);
    } else {
        printf(CYELLOW"/!\\"CRESET" "CRED"HACKING DETECTED"CRESET" "CYELLOW"/!\\"CRESET"\n");
        exit(-1);
    }

    // Exit the program / return from main
}
```

The code here pretty much the same as in level 1, apart from one noticable change. The main function now has an conditional block when calling the `cowsay` function: 

```c
     // Validate the text before printing it, to ensure no funny-business
 92     if (check_for_hacks(text)) {
 93         cowsay(text);
 94     } else {
 95         printf(CYELLOW"/!\\"CRESET" "CRED"HACKING DETECTED"CRESET" "CYELLOW"/!\\"CRESET"\n");
 96         exit(-1);
 97     }
```
Within the if statement, a call is made to `check_for_hacks` with the user supplied `buffer` char array as an argument. If the call returns the result as true, the `cowsay` function will then execute. Alternatively, if the return value from the call to `check_for_hacks` is false, the program is exited with the message `HACKING DETECTED` printed to the terminal.


At the moment, we don't know what the check_for_hacks function is doing to make it's decision, because the function is not shown in the source code. To understand what is happening in this function, we need to review the disassembly for `check_for_hacks` :

```asm
0x4008bd:  push    rbp
0x4008be:  mov     rbp, rsp
0x4008c1:  sub     rsp, 0x20
0x4008c5:  mov     qword [rbp-0x18], rdi
0x4008c9:  mov     rax, qword [rbp-0x18]
0x4008cd:  mov     rdi, rax
0x4008d0:  call    strlen
0x4008d5:  mov     qword [rbp-0x10], rax
0x4008d9:  mov     dword [rbp-0x4], 0x0
0x4008e0:  jmp     0x40097c
0x4008e5:  mov     eax, dword [rbp-0x4]
0x4008e8:  movsxd  rdx, eax
0x4008eb:  mov     rax, qword [rbp-0x18]
0x4008ef:  add     rax, rdx
0x4008f2:  movzx   eax, byte [rax]
0x4008f5:  cmp     al, 0x3b
0x4008f7:  je      0x400971
0x4008f9:  mov     eax, dword [rbp-0x4]
0x4008fc:  movsxd  rdx, eax
0x4008ff:  mov     rax, qword [rbp-0x18]
0x400903:  add     rax, rdx
0x400906:  movzx   eax, byte [rax]
0x400909:  cmp     al, 0x2f
0x40090b:  je      0x400971
0x40090d:  mov     eax, dword [rbp-0x4]
0x400910:  movsxd  rdx, eax
0x400913:  mov     rax, qword [rbp-0x18]
0x400917:  add     rax, rdx
0x40091a:  movzx   eax, byte [rax]
0x40091d:  cmp     al, 0x62
0x40091f:  je      0x400971
0x400921:  mov     eax, dword [rbp-0x4]
0x400924:  movsxd  rdx, eax
0x400927:  mov     rax, qword [rbp-0x18]
0x40092b:  add     rax, rdx
0x40092e:  movzx   eax, byte [rax]
0x400931:  cmp     al, 0x69
0x400933:  je      0x400971
0x400935:  mov     eax, dword [rbp-0x4]
0x400938:  movsxd  rdx, eax
0x40093b:  mov     rax, qword [rbp-0x18]
0x40093f:  add     rax, rdx
0x400942:  movzx   eax, byte [rax]
0x400945:  cmp     al, 0x6e
0x400947:  je      0x400971
0x400949:  mov     eax, dword [rbp-0x4]
0x40094c:  movsxd  rdx, eax
0x40094f:  mov     rax, qword [rbp-0x18]
0x400953:  add     rax, rdx
0x400956:  movzx   eax, byte [rax]
0x400959:  cmp     al, 0x73
0x40095b:  je      0x400971
0x40095d:  mov     eax, dword [rbp-0x4]
0x400960:  movsxd  rdx, eax
0x400963:  mov     rax, qword [rbp-0x18]
0x400967:  add     rax, rdx
0x40096a:  movzx   eax, byte [rax]
0x40096d:  cmp     al, 0x68
0x40096f:  jne     0x400978
0x400971:  mov     eax, 0x0
0x400976:  jmp     0x400990
0x400978:  add     dword [rbp-0x4], 0x1
0x40097c:  mov     eax, dword [rbp-0x4]
0x40097f:  cdqe
0x400981:  cmp     qword [rbp-0x10], rax
0x400985:  ja      0x4008e5
0x40098b:  mov     eax, 0x1
0x400990:  leave
0x400991:  retn

```

Looking at the disassembly, we an see there are a number of checks in place. We'll work through understanding each check separately. 

### Check 1

```asm
0x4008bd:  push    rbp
0x4008be:  mov     rbp, rsp
0x4008c1:  sub     rsp, 0x20
0x4008c5:  mov     qword [rbp-0x18], rdi
0x4008c9:  mov     rax, qword [rbp-0x18]
0x4008cd:  mov     rdi, rax
0x4008d0:  call    strlen
0x4008d5:  mov     qword [rbp-0x10], rax
0x4008d9:  mov     dword [rbp-0x4], 0x0
0x4008e0:  jmp     0x40097c
```
- Aside from the function prologue, we can see 32 bytes is alloated to the stack. 
- The pointer `text` argument to the `check_for_hacks` function is received in the rdi register, then moved to `rbp-0x18`.
- rbp-0x18 (text string) is copied to rax, then to rdi
- The strlen function is called with with rdi as the first arg, which is the text we supply to it
- The return result (length of the text) is stored in rax, then copied to `rbp-0x10`
- 0 is moved into `rbp-0x4` followed by a jmp instruction to `0x40097c`

When we review the remaining instructions at 0x40097c, we can see a comparison is made:

```asm
0x40097c:  mov     eax, dword [rbp-0x4]
0x40097f:  cdqe
0x400981:  cmp     qword [rbp-0x10], rax
0x400985:  ja      0x4008e5
0x40098b:  mov     eax, 0x1
0x400990:  leave
0x400991:  retn
```
A comparison is made between `rax` (which has the value `0` from rbp-0x4) and `rbp-0x10` (which has the length of our text). If the length of the text is greater than zero we pass the check and execution will `jmp` to `0x4008e5`. Alternatively, if it's zero or below, 1 is moved into eax and returned to caller followed by the function exiting.


### Check 2

```asm
0x4008e5:  mov     eax, dword [rbp-0x4]
0x4008e8:  movsxd  rdx, eax
0x4008eb:  mov     rax, qword [rbp-0x18]
0x4008ef:  add     rax, rdx
0x4008f2:  movzx   eax, byte [rax]
0x4008f5:  cmp     al, 0x3b
0x4008f7:  je      0x400971
```

- This takes rbp-0x4 (currently 0), moves it to eax then to rdx
- The pointer to the text string in rbp-0x18 is moved to rax, then has the value in rdx (0) added to it
- The first byte from the string (in rax) is eax, then compared to `0x3b`
- If the comparison was equal, `jmp` to `0x400971`

Looking at 0x400971, we see the following:

```asm
0x400971:  mov     eax, 0x0
0x400976:  jmp     0x400990
0x400978:  add     dword [rbp-0x4], 0x1
0x40097c:  mov     eax, dword [rbp-0x4]
0x40097f:  cdqe
0x400981:  cmp     qword [rbp-0x10], rax
0x400985:  ja      0x4008e5
```
- If the first byte matches 0x3b, then the program exits and 0 is returned to the caller. This would be our failure condition, which would result in the message "HACKING DETECTED" printed to the terminal.
- If the first byte did not match, add 1 to rbp-0x4, compare this with the length of the text string again, and jump to 0x4008e5 if rbp-0x10 is greater

This behaviour forms a loop, and continues througout the program. From this fact can determine the following:

- The check on the user supplied text string, will search through the whole string for specific characters. If any are found, the program exits and alerts Hacking Detected
- The characters being checked are: `0x3b`, `0x2f`, `0x62`, `0x69`, `0x6e`, `0x73`, `0x68`
- This maps to the ascii characters `bin/sh`. The `0x3b` is added because the number in decimal is 59 and is syscall number for `exceve`.


## Our Goal

Now we have reversed engineered the checks being made in the `check_for_hacks` function, we have a clear idea of what we need to do to bypass them. To solve this challenge and get a shell, we need to:

- Create find an alternative binary file to execute to get a shell
- Use a different syscall (Not exceve)
- Alternatively, obfuscate the bin/sh and exceve syscall number in the shell code


