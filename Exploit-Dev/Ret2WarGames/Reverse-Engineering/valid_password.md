# Reverse Engineering Level 2 - Valid Password

## Challenge

We have to reverse engineer the assembly code and encryption algorithm to obtain the password.

## Disassembly

```asm

0x400896:  push    rbp
0x400897:  mov     rbp, rsp
0x40089a:  mov     qword [rbp-0x18], rdi
0x40089e:  mov     dword [rbp-0x4], 0x0
0x4008a5:  jmp     0x4008f6
0x4008a7:  mov     edx, dword [rbp-0x4]
0x4008aa:  mov     rax, qword [rbp-0x18]
0x4008ae:  add     rdx, rax
0x4008b1:  mov     ecx, dword [rbp-0x4]
0x4008b4:  mov     rax, qword [rbp-0x18]
0x4008b8:  add     rax, rcx
0x4008bb:  movzx   eax, byte [rax]
0x4008be:  mov     esi, eax
0x4008c0:  mov     eax, dword [rbp-0x4]
0x4008c3:  mov     ecx, eax
0x4008c5:  mov     eax, ecx
0x4008c7:  shl     eax, 0x6
0x4008ca:  add     eax, ecx
0x4008cc:  xor     eax, esi
0x4008ce:  mov     byte [rdx], al
0x4008d0:  mov     edx, dword [rbp-0x4]
0x4008d3:  mov     rax, qword [rbp-0x18]
0x4008d7:  add     rax, rdx
0x4008da:  movzx   edx, byte [rax]
0x4008dd:  mov     eax, dword [rbp-0x4]
0x4008e0:  movzx   eax, byte [rax+0x601090]
0x4008e7:  cmp     dl, al
0x4008e9:  je      0x4008f2
0x4008eb:  mov     eax, 0x0
0x4008f0:  jmp     0x400901
0x4008f2:  add     dword [rbp-0x4], 0x1
0x4008f6:  cmp     dword [rbp-0x4], 0x15
0x4008fa:  jbe     0x4008a7
0x4008fc:  mov     eax, 0x1
0x400901:  pop     rbp
0x400902:  retn    

```

## Algorithm

1. Get the password
2. Add the current loop iteration to the password (the address of)
3. Get the value of the most significant byte (current member of the password array)
4. Shift loop iteration left by 6
5. Add the current loop iteration number to the shift left result
6. XOR the result of the shift left and loop iter operation with the (current member of the password array)
7. If the result of the XOR is > 128, get the remainder of dividing the result by 128. The remainder will be the ascii character.

## Python script to decrypt

```python

# The bytes from the encrypted password at rax+0x601090
#
# 0x601090: 0xf0f23473    0xf4f51a76    0xbfb93b6b    0xbcba3d53
# 0x6010a0: 0xa1a22663    0x00005570    0x00000000    0x00000000
 

# Create a string of bytes in little endian byte-order
str1 = bytes.fromhex('5570a1a22663bcba3d53bfb93b6bf4f51a76f0f23473')

passwd_array = [x for x in reversed(str1)] # Save the revresed byte string in a list


# The code below will:
# 1. loop through the list
# 2. Shift current index of the loop left by 6
# 3. Add the result of the shift left and the current loop index together
# 4. XOR the previous previous result
# 5. Get the modulus (remainder) of dividing the XOR result by 128 (the ascii charset)
# 6. Print the result as one string and no new lines.

for i in passwd_array:
    print(chr((((passwd_array.index(i)  << 6) + passwd_array.index(i)) ^ i) % 128), end='')
```
