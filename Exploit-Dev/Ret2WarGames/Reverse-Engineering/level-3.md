# Reverse Engineering Level 3 -  Challenge / Response
 
### This is the 3rd and final level in the Reverse Engineering challenges from Ret2 WarGames :sweat_smile:

## The Mission

### Challenge / Response
"Wow, stealing acquiring software is hard work... This one communicates with a server of some kind and makes you submit a ton of valid request-response pairs.

This is a tricky one, but we think you're ready for it."

## Static / Dynamic Analysis
 
Judging by the title, it looks like this level involves us producing a correct response to a challenge we are given. When the program starts, it prints a challenge to the console and asks the user for a response input:

```bash
CHALLENGE: DLKZA-RQTTQ-SWIGA-TZDRM-QVVAG
RESPONSE:
```

If you supply some random data in the response field you will see the message `INCORRECT RESPONSE! (ERROR CODE 2)` and the program terminates. 

The first check point (hint) in the level says `"Produce the first segment of a valid response".` From this statement, we can infer that we should probably be looking into the disassembly for the `valid_response` function.

When you look at the disassembled function, you'll instantly notice that it is much larger than the previous two levels and feels quite intimidating.  


```asm

0x400b86:  push    rbp
0x400b87:  mov     rbp, rsp
0x400b8a:  sub     rsp, 0x70
0x400b8e:  mov     qword [rbp-0x68], rdi
0x400b92:  mov     qword [rbp-0x70], rsi
0x400b96:  mov     rax, qword [fs:0x28]
0x400b9f:  mov     qword [rbp-0x8], rax
0x400ba3:  xor     eax, eax
0x400ba5:  mov     dword [rbp-0x40], 0x0
0x400bac:  mov     byte [rbp-0x3c], 0x0
0x400bb0:  mov     qword [rbp-0x30], 0x0
0x400bb8:  mov     qword [rbp-0x28], 0x0
0x400bc0:  mov     qword [rbp-0x20], 0x0
0x400bc8:  mov     qword [rbp-0x18], 0x0
0x400bd0:  mov     dword [rbp-0x5c], 0x0
0x400bd7:  mov     dword [rbp-0x4c], 0x0
0x400bde:  mov     dword [rbp-0x58], 0x0
0x400be5:  jmp     0x400c02
0x400be7:  shl     dword [rbp-0x5c], 0x7
0x400beb:  mov     edx, dword [rbp-0x58]
0x400bee:  mov     rax, qword [rbp-0x68]
0x400bf2:  add     rax, rdx
0x400bf5:  movzx   eax, byte [rax]
0x400bf8:  movsx   eax, al
0x400bfb:  xor     dword [rbp-0x5c], eax
0x400bfe:  add     dword [rbp-0x58], 0x1
0x400c02:  cmp     dword [rbp-0x58], 0x4
0x400c06:  jbe     0x400be7
0x400c08:  mov     rax, qword [rbp-0x70]
0x400c0c:  mov     esi, 0x401018
0x400c11:  mov     rdi, rax
0x400c14:  call    strtok
0x400c19:  mov     qword [rbp-0x48], rax
0x400c1d:  cmp     qword [rbp-0x48], 0x0
0x400c22:  jne     0x400c2e
0x400c24:  mov     eax, 0x1
0x400c29:  jmp     0x400d83
0x400c2e:  mov     rax, qword [rbp-0x48]
0x400c32:  mov     rdi, rax
0x400c35:  call    atol
0x400c3a:  mov     dword [rbp-0x4c], eax
0x400c3d:  mov     eax, dword [rbp-0x4c]
0x400c40:  cmp     eax, dword [rbp-0x5c]
0x400c43:  je      0x400c4f
0x400c45:  mov     eax, 0x2
0x400c4a:  jmp     0x400d83
0x400c4f:  mov     dword [rbp-0x54], 0x0
0x400c56:  jmp     0x400cc5
0x400c58:  mov     eax, dword [rbp-0x54]
0x400c5b:  movzx   edx, byte [rbp+rax-0x40]
0x400c60:  mov     eax, dword [rbp-0x54]
0x400c63:  add     eax, 0x6
0x400c66:  mov     ecx, eax
0x400c68:  mov     rax, qword [rbp-0x68]
0x400c6c:  add     rax, rcx
0x400c6f:  movzx   eax, byte [rax]
0x400c72:  xor     edx, eax
0x400c74:  mov     eax, dword [rbp-0x54]
0x400c77:  mov     byte [rbp+rax-0x40], dl
0x400c7b:  mov     eax, dword [rbp-0x54]
0x400c7e:  movzx   edx, byte [rbp+rax-0x40]
0x400c83:  mov     eax, dword [rbp-0x54]
0x400c86:  add     eax, 0xc
0x400c89:  mov     ecx, eax
0x400c8b:  mov     rax, qword [rbp-0x68]
0x400c8f:  add     rax, rcx
0x400c92:  movzx   eax, byte [rax]
0x400c95:  xor     edx, eax
0x400c97:  mov     eax, dword [rbp-0x54]
0x400c9a:  mov     byte [rbp+rax-0x40], dl
0x400c9e:  mov     eax, dword [rbp-0x54]
0x400ca1:  movzx   edx, byte [rbp+rax-0x40]
0x400ca6:  mov     eax, dword [rbp-0x54]
0x400ca9:  add     eax, 0x12
0x400cac:  mov     ecx, eax
0x400cae:  mov     rax, qword [rbp-0x68]
0x400cb2:  add     rax, rcx
0x400cb5:  movzx   eax, byte [rax]
0x400cb8:  xor     edx, eax
0x400cba:  mov     eax, dword [rbp-0x54]
0x400cbd:  mov     byte [rbp+rax-0x40], dl
0x400cc1:  add     dword [rbp-0x54], 0x1
0x400cc5:  cmp     dword [rbp-0x54], 0x4
0x400cc9:  jbe     0x400c58
0x400ccb:  mov     dword [rbp-0x50], 0x0
0x400cd2:  jmp     0x400d06
0x400cd4:  mov     eax, dword [rbp-0x50]
0x400cd7:  movzx   eax, byte [rbp+rax-0x40]
0x400cdc:  movsx   eax, al
0x400cdf:  mov     edx, dword [rbp-0x50]
0x400ce2:  lea     ecx, [rdx+rdx]
0x400ce5:  lea     rdx, [rbp-0x30]
0x400ce9:  mov     ecx, ecx
0x400ceb:  add     rcx, rdx
0x400cee:  mov     edx, eax
0x400cf0:  mov     esi, 0x40101a {"%02X"
0x400cf5:  mov     rdi, rcx
0x400cf8:  mov     eax, 0x0
0x400cfd:  call    sprintf
0x400d02:  add     dword [rbp-0x50], 0x1
0x400d06:  cmp     dword [rbp-0x50], 0x4
0x400d0a:  jbe     0x400cd4
0x400d0c:  mov     esi, 0x401018
0x400d11:  mov     edi, 0x0
0x400d16:  call    strtok
0x400d1b:  mov     qword [rbp-0x48], rax
0x400d1f:  cmp     qword [rbp-0x48], 0x0
0x400d24:  jne     0x400d2d
0x400d26:  mov     eax, 0x3
0x400d2b:  jmp     0x400d83
0x400d2d:  lea     rdx, [rbp-0x30]
0x400d31:  mov     rax, qword [rbp-0x48]
0x400d35:  mov     rsi, rdx
0x400d38:  mov     rdi, rax
0x400d3b:  call    strcmp
0x400d40:  test    eax, eax
0x400d42:  je      0x400d4b
0x400d44:  mov     eax, 0x4
0x400d49:  jmp     0x400d83
0x400d4b:  mov     esi, 0x40101f
0x400d50:  mov     edi, 0x0
0x400d55:  call    strtok
0x400d5a:  mov     qword [rbp-0x48], rax
0x400d5e:  cmp     qword [rbp-0x48], 0x0
0x400d63:  jne     0x400d6c
0x400d65:  mov     eax, 0x5
0x400d6a:  jmp     0x400d83
0x400d6c:  mov     rax, qword [rbp-0x68]
0x400d70:  lea     rdx, [rax+0x18]
0x400d74:  mov     rax, qword [rbp-0x48]
0x400d78:  mov     rsi, rax
0x400d7b:  mov     rdi, rdx
0x400d7e:  call    validate_final
0x400d83:  mov     rsi, qword [rbp-0x8]
0x400d87:  xor     rsi, qword [fs:0x28]
0x400d90:  je      0x400d97
0x400d92:  call    __stack_chk_fail
0x400d97:  leave
0x400d98:  retn

```

That was 130 lines of Assembly output :astonished:

The first step is to break disassembled function into small pieces of logic. We know that we need to produce the first segment of a valid response, so it makes sense to start with the first set of instructions between `0x400b86` and `0x400be5`.

```asm
0x400b86:  push    rbp
0x400b87:  mov     rbp, rsp
0x400b8a:  sub     rsp, 0x70
0x400b8e:  mov     qword [rbp-0x68], rdi    ; Challenge
0x400b92:  mov     qword [rbp-0x70], rsi    ; Response
0x400b96:  mov     rax, qword [fs:0x28]
0x400b9f:  mov     qword [rbp-0x8], rax
0x400ba3:  xor     eax, eax
0x400ba5:  mov     dword [rbp-0x40], 0x0
0x400bac:  mov     byte [rbp-0x3c], 0x0
0x400bb0:  mov     qword [rbp-0x30], 0x0
0x400bb8:  mov     qword [rbp-0x28], 0x0
0x400bc0:  mov     qword [rbp-0x20], 0x0
0x400bc8:  mov     qword [rbp-0x18], 0x0
0x400bd0:  mov     dword [rbp-0x5c], 0x0
0x400bd7:  mov     dword [rbp-0x4c], 0x0
0x400bde:  mov     dword [rbp-0x58], 0x0
0x400be5:  jmp     0x400c02
```
The above instructions do the following: 

1. Setup the function prologue (0x400b86 to 0x400b8a).
2. Move 2 arguments received by the function in `rdi` and `rsi` into memory locations `rbp-0x68` and `rbp-0x70`
3. Get's a value from `fs:0x28` and saves it to rax, then to memory location `rbp-0x8`
4. The remaining instructions up to `0x400be5` set some variables (memory locations) to 0 and then moves the execution (`jmp`) to the next section of instructions beginning at `0x400c02`

### Segment 1

The section of instructions at `0x400c02` form the first loop of the program and some initial logic: 

```asm
0x400be7:  shl     dword [rbp-0x5c], 0x7
0x400beb:  mov     edx, dword [rbp-0x58]    ; Loop counter
0x400bee:  mov     rax, qword [rbp-0x68]    ; Pointer to Challenge characters e.g. DLKZA-RQTTQ-SWIGA-TZDRM-QVVAG
0x400bf2:  add     rax, rdx                 ; Add the pointer (memory address) or challenge chars and the loop counter (result saved to rax)
0x400bf5:  movzx   eax, byte [rax]          ; Zero extend the first byte of the dereferenced pointer value
0x400bf8:  movsx   eax, al          
0x400bfb:  xor     dword [rbp-0x5c], eax    ; XOR the dereferenced byte with the variable rbp-0x5c
0x400bfe:  add     dword [rbp-0x58], 0x1
0x400c02:  cmp     dword [rbp-0x58], 0x4    
0x400c06:  jbe     0x400be7
```
At `0x400c02` a comparison (`cmp`) is made between `0x4` and the variable `rbp-0x58`. The next instruction `0x400c06` will move the program execution back to `0x400be7` if `rbp-0x58` was not equal to `0x4`.The `cmp` and `jne` instructions control the loop, forcing repeated execution of instructions between `0x400be7` and `0x400bfe` until `rbp-0x58` is 4. The explanation of the logic within the loop is shown below:

1. Shift the value in `rbp-0x5c` left by 7. This value is intially `0`.
2. Add the current loop iteration (`rbp-0x58`) and the pointer to the challenge (`rbp-0x68`)
3. Get the most significant byte (`little endian`) from the deferenced previous result
4. XOR the `rbp-0x5c` and the byte from the previous result in `eax`
5. Add one to the current loop and repeat four more times (because we start at index 0)
6. When the loop has completed 5 iterations, continue to the next set of instructions.


The next set of instructions between `0x400c08` and `0x400c29` continues the program's first segment logic (shown below). 

```asm
0x400c08:  mov     rax, qword [rbp-0x70]    ; The response that was entered by the user
0x400c0c:  mov     esi, 0x401018            ; Tokens to check for
0x400c11:  mov     rdi, rax                 
0x400c14:  call    strtok                   ; The C funtion strtok. This gets searches and returns the response string chars until a token is found
0x400c19:  mov     qword [rbp-0x48], rax    
0x400c1d:  cmp     qword [rbp-0x48], 0x0    ; Check that the returned value is not zero 
0x400c22:  jne     0x400c2e
0x400c24:  mov     eax, 0x1
0x400c29:  jmp     0x400d83
```

The first 3 lines setup the call to the C function `strtok` which is used to break a string into a series of tokens using a delimeter. The call to `strtok` only gets the first token and returns a pointer to the token. If a token was not found, a NULL pointer (0) is returned.
The key component here is the `jne` at `0x400c22`. If `rbp-0x48` is not equal to zero, the program execution continues to `0x400c2e` and the next section of instructions will begin. 
However, if the comparison was equal, the program execution is directed to `0x400d83` which performs a stack cookie check to validate the stacks integrity, and follows on to terminate the program.

The instructions between `0x400c2e` and `0x400c4a` are the last set that make up the first segment. A summary of the logic is commented alongside the code below:

```asm
0x400c2e:  mov     rax, qword [rbp-0x48]    ; Deference the pointer to the string returned from strtok
0x400c32:  mov     rdi, rax
0x400c35:  call    atol                     ; Convert this string's data type to a long number
0x400c3a:  mov     dword [rbp-0x4c], eax
0x400c3d:  mov     eax, dword [rbp-0x4c]    ; Save the new long number to eax
0x400c40:  cmp     eax, dword [rbp-0x5c]    ; Compare the long number with the value in rbp-0x5c, which was the result of the final XOR in previous loop
0x400c43:  je      0x400c4f                 ; Jump to the next set of instructions at 0x400c4f if the cmp result was equal
0x400c45:  mov     eax, 0x2
0x400c4a:  jmp     0x400d83                 ; JMP to 0x400d83 and continue to terminate the program
```

This means that the end result of the calculations (shl, xor) in the previous loop stored in `rbp-0x5c` must match the result returned from the call to strtok when compared as type `long` numbers.
To get past the first step we need to use a python script to get the challenge value presented by the program, so we can start doing the calculations in the loop produce the correct result.

```python
import interact
import re


p = interact.Process()              # Instantiate the Ret2 Wargames interact class to create a 
                                    # Process object that we can use to interact with the running program 
data = p.readuntil('RESPONSE:')     # Use the readuntil method to get the program text that was printed to STDOUT (as a byte string)
challenge_str = re.search("(?<=:\s).*(?=\\n)", data.decode('utf-8')).group(0)       # Use regex to get the challenge string (decoded byte string)
challenge_ascii_list = [ord(x) for x in challenge_str]      # Create a list converting each character to its ascii number in decimal

print(f'{data}\n')                  # This will print the bytes sent to STDOUT from the running program
print(f'{challenge_str}\n')         # This will print the challenge string we obtained via regex. I've left this in for debugging purposes. 

x = 0                               # Used as a variable to represent rbp-0x5c
response = []                       # Used to capture the computed result after each iteration (for debugging purposes)

for i in range(5):                      # Loop for 5 iterations
    x = x << 7                          # Shift the value of x (rbp-0x5c) left by 7
    x = ((challenge_ascii_list[i]) ^ x) # XOR the ascii character with the previous result of x
    response.append(hex(x))             # This isn't needed, but I added each xor'd result to a list for debugging, to make sure the values were correct. 

print(response)                         # Print the list of computed values to the terminal to see what they were
print(x)                                # Print the final computed value to the terminal. This is what we will send as a response. 


p.sendline(f'{x}')                      # Send the numerical value of x as a string to be input as the response in the program
p.interactive()                         # Use the interactive method to enable debugging capability through the script 
                                        # This will cause the program to break on any break points set in the debugger 
```

When the script is run, we get a check mark to tell us that we have produced the first segement :white_check_mark: 
We can now analyse what is happening in the following segement :smirk:


### Segment 2



```asm
0x400c4f:  mov     dword [rbp-0x54], 0x0        ; Loop counter
0x400c56:  jmp     0x400cc5
0x400c58:  mov     eax, dword [rbp-0x54]
0x400c5b:  movzx   edx, byte [rbp+rax-0x40]     ; Used as a var and starts with 0 initially
0x400c60:  mov     eax, dword [rbp-0x54]
0x400c63:  add     eax, 0x6                     ; Add loop counter and rbp+rax-0x40 into eax
0x400c66:  mov     ecx, eax                     ; Move the addition result to ecx
0x400c68:  mov     rax, qword [rbp-0x68]        ; Move the Pointer to the Challenge string to rax
0x400c6c:  add     rax, rcx                     ; Add the previous addition result and the challenge pointer into rax
0x400c6f:  movzx   eax, byte [rax]              ; Dereference the pointer (+ the addition), get the first byte and save into eax
0x400c72:  xor     edx, eax                     ; XOR the byte saved in eax and rbp+rax-0x40 (save the result in edx)
0x400c74:  mov     eax, dword [rbp-0x54]        ; Move the loop counter to eax
0x400c77:  mov     byte [rbp+rax-0x40], dl      ; Move the result of the XOR (the first byte) into the var rbp+rax-0x40
0x400c7b:  mov     eax, dword [rbp-0x54]        
0x400c7e:  movzx   edx, byte [rbp+rax-0x40]     ; Move the result of XOR saved in rbp+rax-0x40 to edx
0x400c83:  mov     eax, dword [rbp-0x54]        ; Move the loop counter to eax
0x400c86:  add     eax, 0xc                     ; Add 12 to eax
0x400c89:  mov     ecx, eax                     ; Move the value in eax (12 + loop counter) to ecx
0x400c8b:  mov     rax, qword [rbp-0x68]        ; Move the Pointer to the Challenge string to rax        
0x400c8f:  add     rax, rcx                     ; Add the previous addition result saved in ecx and the challenge pointer into rax
0x400c92:  movzx   eax, byte [rax]              ; Dereference the pointer (+ the addition), get the first byte and save into eax
0x400c95:  xor     edx, eax                     ; XOR the previous XOR result and the byte (from the derefenced pointer + addition)
0x400c97:  mov     eax, dword [rbp-0x54]        ; Move the loop counter to eax
0x400c9a:  mov     byte [rbp+rax-0x40], dl      ; Move the result of the XOR (the first byte) into the var rbp+rax-0x40
0x400c9e:  mov     eax, dword [rbp-0x54]
0x400ca1:  movzx   edx, byte [rbp+rax-0x40]     ; Move the result of XOR saved in rbp+rax-0x40 to edx
0x400ca6:  mov     eax, dword [rbp-0x54]        ; Move the loop counter to eax        
0x400ca9:  add     eax, 0x12                    ; Add 18 and the loop counter and save in eax
0x400cac:  mov     ecx, eax                     ; Move the value in eax (18 + loop counter) to ecx
0x400cae:  mov     rax, qword [rbp-0x68]        ; Move the Pointer to the Challenge string to rax        
0x400cb2:  add     rax, rcx                     ; Add the previous addition result saved in ecx and the challenge pointer into rax
0x400cb5:  movzx   eax, byte [rax]
0x400cb8:  xor     edx, eax
0x400cba:  mov     eax, dword [rbp-0x54]
0x400cbd:  mov     byte [rbp+rax-0x40], dl
0x400cc1:  add     dword [rbp-0x54], 0x1        ; Add 1 to the loop
0x400cc5:  cmp     dword [rbp-0x54], 0x4        ; Check if the loop iteration is at index 4
0x400cc9:  jbe     0x400c58                     ; Jmp back to 0x400c58 until loop index is 4 (5 iterations)
```


1. Add 6 to eax then move to ecx
2. Move the pointer to the challenge string `rbp-0x68` to `rax` then add 6 (`ecx`), then zero extend the byte at this position. This selects index 6 (6th character) of the challenge string.
3. XOR this byte with `edx` (`rbp+rax-0x40`)
4. Move the first byte of result of the XOR into `dl` then into `rbp+rax-0x40`
5. Add the loop iteration and 12 `0xc` to `eax`
6. Move the result `eax` into `ecx`, move the pointer to the challenge string `rbp-0x68` into `rax` then add `rcx` to `rax` (pointer to challenge string). This basically gets the `12th` + `loop-counter` character of the challenge string.
7. XOR the character `eax` with `edx` (the result of the previous previous XOR) and save the result (the first byte) into `rbp+rax-0x40`
8. Move `rbp+rax-0x40` into `edx`
9. Add the loop counter `rbp-0x54` and `0x12`(18), then move the value to `ecx`
10. Add `rcx` into `rax` (the pointer to the challenge). This gets the `18th` + `loop-counter`  character from the challenge string
11. XOR the character (`rax`) with `edx` (the result of the previous previous XOR) and save the result (the first byte) into `rbp+rax-0x40`
12. Add 1 to the loop counter `rbp-0x54`
13. Check if `rbp-0x54` is 4 (completed 5 iterations), if not, start the loop again (go to `0x400c58`). If `rbp-0x54` is 4, continue to the next instruction at `0x400ccb`

Although we have mapped out the algorithm, when I orginally wrote the python code I treated `rbp+rax-0x40` as a variable that just gets its value replaced with the result after each XOR, however this turned out to be incorrect. When you run the program through the debugger, the `rbp+rax-0x40` value is updated throughout the first loop iteration, but is reset to 0 at the end of the loop. This pattern continues for the additional 4 loops. 


This is good, but we still have to find out how the values are processed after the 5 iteration when execution is moved to `0x400ccb`. Let's look at the next set of instructions:

```asm
0x400ccb:  mov     dword [rbp-0x50], 0x0
0x400cd2:  jmp     0x400d06
0x400cd4:  mov     eax, dword [rbp-0x50]
0x400cd7:  movzx   eax, byte [rbp+rax-0x40]
0x400cdc:  movsx   eax, al
0x400cdf:  mov     edx, dword [rbp-0x50]
0x400ce2:  lea     ecx, [rdx+rdx]
0x400ce5:  lea     rdx, [rbp-0x30]
0x400ce9:  mov     ecx, ecx
0x400ceb:  add     rcx, rdx
0x400cee:  mov     edx, eax
0x400cf0:  mov     esi, 0x40101a {"%02X"
0x400cf5:  mov     rdi, rcx
0x400cf8:  mov     eax, 0x0
0x400cfd:  call    sprintf
0x400d02:  add     dword [rbp-0x50], 0x1
0x400d06:  cmp     dword [rbp-0x50], 0x4
0x400d0a:  jbe     0x400cd4
```
Initially, at `0x400ccb` we can see `0x0` being moved into `rbp-0x50` then at `0x400cd2` a `jmp` instruction to `0x400d06`. If you look at `0x400d02` and `0x400d06`, we can see that `0x1` is added to `rbp-0x50` then compared with `0x4`. The next instruction at `0x400d0a` will send program execution back to `0x400cd4` is the `cmp` value was less than or equal to 0x4. This behaviour forms another loop. 


The instructions in the loop do the following:

1. Set the loop counter `rbp-0x50` to 0 initially
2. Get the first byte from the variable `rbp+rax-0x40`
3. Add the loop counter `rbp-0x50` which is saved in `rdx` with itself (rdx+rdx), then save to `ecx`
4. Load the address of `rbp-0x30` into `rdx` and add this to `rcx`. This basically gives us the pointer + (loop counter x2)
5. Move the byte from `rbp+rax-0x40` currently saved in `eax` to edx.
6. Move the the bytes `0x40101a` to `esi`. This maps to the string `%02X`, and is used for the format string in the upcoming all to `sprintf`
7. Move the calculated pointer in step 4, to rdi
8. Call `sprintf` with arguments `edx` (the byte from `rbp+rax-0x40`), `esi` (the format `%02X`), and `rdi` (the calculated pointer `rbp-0x30` + `loop counter x2`). Sprintf will get the byte character `edx` in the format `%02X` and save it to the pointer of char elements (`rbp-0x30`)
9. Add 1 to the loop and continue 4 more times until 5 iterations are complete.

This effectively takes the first 5 bytes saved in `rbp+rax-0x40` and saved them in hex with upper-case formatting `%02X`. When you inspect the bytes from `rbp+rax-0x40`, we can see this is all processed XORresults from the computation done on the 4th block of the challenge string. 


Once 5 iterations have been completed, we move on to the next set of instructions where the values previously calcuated are compared to what we entered when sending the response at the start of the program:

```asm
0x400d0c:  mov     esi, 0x401018            ; Tokens to check for
0x400d11:  mov     edi, 0x0
0x400d16:  call    strtok                   ; Call to strtok. This gets the next block (segment) from the response enter at the start of the program
0x400d1b:  mov     qword [rbp-0x48], rax
0x400d1f:  cmp     qword [rbp-0x48], 0x0    ; Check a null pointer wasn't returned
0x400d24:  jne     0x400d2d                 ; Go to 0x400d2d if we got a pointer to chars
0x400d26:  mov     eax, 0x3
0x400d2b:  jmp     0x400d83                 ; Failure case ... continues on to terminate program
0x400d2d:  lea     rdx, [rbp-0x30]          ; Load the address of the 5 bytes we saved in rbp-0x30 and save it in rdx 
0x400d31:  mov     rax, qword [rbp-0x48]    ; Move the response chars in rax
0x400d35:  mov     rsi, rdx                 ; Move the calculated 5 bytes (string) into rsi to prepare for strcmp call
0x400d38:  mov     rdi, rax                 ; Move the challenge chars into rdi to prepare for strcmp call
0x400d3b:  call    strcmp                   ; Compare the strings 
0x400d40:  test    eax, eax                 
0x400d42:  je      0x400d4b                 ; Go to 0x400d4b if the strings match
0x400d44:  mov     eax, 0x4
0x400d49:  jmp     0x400d83                 ; Failure case, continues on to terminate the program
```
The above instructions simply take the next block of the response string and compares it to the string of 5 bytes that we calculated from the previous XORs. If they match we move to the next set of instructions at `0x400d4b`. The key thing here is that we are comparing string, so we know the next block we send in the response needs to be a string. Secondly, we know the string value we send must be the calculated XOR values from the 3rd section of that loop (from the 18th character of the challenge string to the 22nd). Since we are sending the values computed on the 4th segment of the challenge string next, we also need to send the 3rd after that, followed by the 2nd. 

At this point we can modify our python script to test this out and check if we are correct. We also refactor the script to try and make things clearer: 

```python
import interact
import struct
import re


p = interact.Process()
data = p.readuntil('RESPONSE:')
challenge_str = re.search("(?<=:\s).*(?=\\n)", data.decode('utf-8')).group(0)
challenge_ascii_list = [ord(x) for x in challenge_str]

print(f'Challenge String: {challenge_str}\n')

# First Segment
first_seg = 0
first_seg_list = []

for i in range(5):
    first_seg = first_seg << 7
    first_seg = ((challenge_ascii_list[i]) ^ first_seg)
    first_seg_list.append(hex(first_seg))

print(f'First Segment Computation: {first_seg_list}')

# Second Segment
second_seg = 0      # rbp+rax-0x40
block_2 = ""
block_3 = ""
block_4 = ""

for i in range(5):
    second_seg = ((challenge_ascii_list[i + 6]) ^ second_seg)
    block_2 += hex(second_seg)[2:].upper()
    print(f'Block_2_Iteration {i}: char {chr(challenge_ascii_list[i + 6])} ^ second_seg = {hex(second_seg)} --> Block_2 = 0x{block_2}')

    second_seg = ((challenge_ascii_list[i + 12]) ^ second_seg)
    block_3 += hex(second_seg)[2:].upper()
    print(f'Block_3_Iteration {i}: char {chr(challenge_ascii_list[i + 12])} ^ second_seg = {hex(second_seg)} --> Block_3 = 0x{block_3}')

    second_seg = ((challenge_ascii_list[i + 18]) ^ second_seg)
    block_4 += hex(second_seg)[2:].upper()
    print(f'Block_4_Iteration {i}: char {chr(challenge_ascii_list[i + 18])} ^ second_seg = {hex(second_seg)} --> Block_4 = 0x{block_4}')
    second_seg = 0

RESP = f'{first_seg}/{block_4}/{block_3}/{block_2}'
print(f'Sending: {RESP}')

p.sendline(RESP)
p.interactive()
```
After running the script we get another check mark to show we have completed the second segment. We can also see the printed values from the script:

```bash
$ python3 exploit.py
Challenge String: FYXXY-KZSBN-ITJEW-LLLYU-RZJWU
First Segment Computation: ['0x46', '0x2359', '0x11acd8', '0x8d66c58', '0x46b362c59']
Block_2_Iteration 0: char K ^ second_seg = 0x4b --> Block_2 = 0x4B
Block_3_Iteration 0: char I ^ second_seg = 0x2 --> Block_3 = 0x2
Block_4_Iteration 0: char L ^ second_seg = 0x4e --> Block_4 = 0x4E
Block_2_Iteration 1: char Z ^ second_seg = 0x5a --> Block_2 = 0x4B5A
Block_3_Iteration 1: char T ^ second_seg = 0xe --> Block_3 = 0x2E
Block_4_Iteration 1: char L ^ second_seg = 0x42 --> Block_4 = 0x4E42
Block_2_Iteration 2: char S ^ second_seg = 0x53 --> Block_2 = 0x4B5A53
Block_3_Iteration 2: char J ^ second_seg = 0x19 --> Block_3 = 0x2E19
Block_4_Iteration 2: char L ^ second_seg = 0x55 --> Block_4 = 0x4E4255
Block_2_Iteration 3: char B ^ second_seg = 0x42 --> Block_2 = 0x4B5A5342
Block_3_Iteration 3: char E ^ second_seg = 0x7 --> Block_3 = 0x2E197
Block_4_Iteration 3: char Y ^ second_seg = 0x5e --> Block_4 = 0x4E42555E
Block_2_Iteration 4: char N ^ second_seg = 0x4e --> Block_2 = 0x4B5A53424E
Block_3_Iteration 4: char W ^ second_seg = 0x19 --> Block_3 = 0x2E19719
Block_4_Iteration 4: char U ^ second_seg = 0x4c --> Block_4 = 0x4E42555E4C
Sending: 18978581593/4E42555E4C/2E19719/4B5A53424E
```

Now we can move on to the next set of instructions and attempt to try and produce a valid response.


### Producing a Valid Response

The next set of instructions sets the stage for a call to the `validate_final` function, where the remaining 5th block of the Challenge string is processed and the whole string checked to verify if the response was correct. A break down of the remaining `valid_response` function is annotated below: 

```asm
0x400d4b:  mov     esi, 0x40101f
0x400d50:  mov     edi, 0x0
0x400d55:  call    strtok
0x400d5a:  mov     qword [rbp-0x48], rax
0x400d5e:  cmp     qword [rbp-0x48], 0x0
0x400d63:  jne     0x400d6c
0x400d65:  mov     eax, 0x5
0x400d6a:  jmp     0x400d83
0x400d6c:  mov     rax, qword [rbp-0x68]
0x400d70:  lea     rdx, [rax+0x18]              ; 5th segment of challenge string chars
0x400d74:  mov     rax, qword [rbp-0x48]        ; 3rd segment of response chars
0x400d78:  mov     rsi, rax
0x400d7b:  mov     rdi, rdx
0x400d7e:  call    validate_final
0x400d83:  mov     rsi, qword [rbp-0x8]
0x400d87:  xor     rsi, qword [fs:0x28]
0x400d90:  je      0x400d97
```

The above function takes the 5th section of the challenge string (last 5 chars) and takes the 3rd section of our response string (5 chars), then uses them for input in the call to the `validate_final` function. Now we can take a look at the `validate_final` function and see what is happening.


```asm
0x400a9d:  push    rbp
0x400a9e:  mov     rbp, rsp
0x400aa1:  sub     rsp, 0x40
0x400aa5:  mov     qword [rbp-0x38], rdi        ; Move the pointer to the last 5 chars from the challenge string into rbp-0x38
0x400aa9:  mov     qword [rbp-0x40], rsi        ; Move the 3rd block from the response string (taken from the XOR on the 12th - 16th chars of the challenge str) 
0x400aad:  mov     rax, qword [fs:0x28]         
0x400ab6:  mov     qword [rbp-0x8], rax
0x400aba:  xor     eax, eax
0x400abc:  mov     qword [rbp-0x20], 0x0
0x400ac4:  mov     qword [rbp-0x18], 0x0
0x400acc:  mov     dword [rbp-0x28], 0x0        ; Loop counter intialized to zero
0x400ad3:  jmp     0x400b20

0x400ad5:  mov     eax, dword [rbp-0x28]        ; Move loop counter into eax
0x400ad8:  movzx   eax, byte [rax+0x6020b0]     ; Move  byte from rax+0x6020b0 into eax [0x6020b0: 0x7d5b38f8    0x00004905]
0x400adf:  movzx   edx, al                      ; Move the byte to edx (i.e f8 intially)
0x400ae2:  mov     ecx, dword [rbp-0x28]        ; Move the loop counter to ecx
0x400ae5:  mov     rax, qword [rbp-0x38]        ; Move the pointer to the 5 chars from the challenge str into rax
0x400ae9:  add     rax, rcx                     ; Add loop counter and the pointer, save the result in rax
0x400aec:  movzx   eax, byte [rax]              ; Dereference the pointer and move the first byte to eax
0x400aef:  movsx   eax, al                      
0x400af2:  mov     ecx, edx                     ; Move the byte from rax+0x6020b0 saved in edx to ecx
0x400af4:  imul    ecx, eax                     ; Signed multiply the byte from rax+0x6020b0 and the byte from the dereferenced challenge str, save the result to ecx
0x400af7:  mov     edx, 0x4ec4ec4f              ; Move 0x4ec4ec4f (4 bytes) into edx 
0x400afc:  mov     eax, ecx                     ; Move the result of the previous multiplication in eax
0x400afe:  imul    edx                          ; Signed multiply 0x4ec4ec4f and eax (previous multiply result) the save the first 4 bytes into edx
0x400b00:  sar     edx, 0x3                     ; Shift the new multiply result in edx right by 3 bits, save the result in edx
0x400b03:  mov     eax, ecx                     ; Move the result of the multiply on the byte from rax+0x6020b0 and the deref pointer to eax
0x400b05:  sar     eax, 0x1f                    ; Shift the result right by 31 and save new result to eax 
0x400b08:  sub     edx, eax                     ; Subtract the previous SAR result from edx (new multiply result shifted right by 3), saved result to edx
0x400b0a:  mov     eax, edx                     ; Move previous result to eax
0x400b0c:  imul    eax, eax, 0x1a               ; Multiply result in eax and 26, then save result in eax
0x400b0f:  sub     ecx, eax                     ; Subtract previous result from the ecx (result of the multiply on the byte from rax+0x6020b0 and the deref pointer)
0x400b11:  mov     eax, ecx                     ; Move previous result to eax
0x400b13:  mov     edx, eax                     ; Move previous result to edx
0x400b15:  mov     eax, dword [rbp-0x28]        ; Move loop counter to eax
0x400b18:  mov     byte [rbp+rax-0x20], dl      ; Move one byte from edx to rbp+rax-0x20
0x400b1c:  add     dword [rbp-0x28], 0x1        ; Add one to the loop counter
0x400b20:  cmp     dword [rbp-0x28], 0x4        ; Check if 5 iterations has comeplted
0x400b24:  jbe     0x400ad5                     ; Go back to 0x400ad5 until 5 iterations have completed

0x400b26:  mov     dword [rbp-0x24], 0x0
0x400b2d:  jmp     0x400b47

0x400b2f:  mov     eax, dword [rbp-0x24]        ; Loop counter
0x400b32:  movzx   eax, byte [rbp+rax-0x20]     ; Move the dereferenced pointer to the first byte of the computed value at the end of the previous loop, save to eax
0x400b37:  add     eax, 0x41                    ; Add 65 to the byte saved in eax
0x400b3a:  mov     edx, eax                     ; Move the previous result to edx
0x400b3c:  mov     eax, dword [rbp-0x24]        ; Move the loop counter to eax
0x400b3f:  mov     byte [rbp+rax-0x20], dl      ; Move the previous result to one byte in rbp+rax-0x20
0x400b43:  add     dword [rbp-0x24], 0x1        ; Add 1 to the loop counter
0x400b47:  cmp     dword [rbp-0x24], 0x4        ; Check if 5 iterations has completed
0x400b4b:  jbe     0x400b2f                     ; Go back to 0x400b2f until 5 iter has completed

0x400b4d:  lea     rdx, [rbp-0x20]              ; Move the address of rbp-0x20 into rdx. This is the final 5 char string computed at the end of the previous loop
0x400b51:  mov     rax, qword [rbp-0x40]        ; The 5 characters sent in the 3rd block of the response string
0x400b55:  mov     rsi, rdx
0x400b58:  mov     rdi, rax
0x400b5b:  call    strcmp
0x400b60:  test    eax, eax
0x400b62:  je      0x400b6b
0x400b64:  mov     eax, 0x6
0x400b69:  jmp     0x400b70
0x400b6b:  mov     eax, 0x0
0x400b70:  mov     rsi, qword [rbp-0x8]
0x400b74:  xor     rsi, qword [fs:0x28]
0x400b7d:  je      0x400b84
0x400b7f:  call    __stack_chk_fail
0x400b84:  leave
0x400b85:  retn
```

The logic for the disassembled function above can be broken down as follows:

1. Create the first loop of 5 iterations with variables for `rbp+rax-0x20` and the last 5 characters from the challenge string
2. Take the first char from the challenge str and multiply it with the first byte from `0x7d5b38f8`
3. Multiply the previous result with `0x4ec4ec4f`
4. Shift the previous result right by 3
5. Shift the first multipy result in step 2 right by 31
6. Subtract the previous result from first shift right result
7. Save the previous result to `rbp+rax-0x20`
8. Add 1 to the loop counter and repeat steps 1 to 8 until 5 iterations have completed

9. Setup another loop of 5 iterations
10. Get the first byte from `rbp+rax-0x20` and add `0x41` to it
11. Save the result to `rbp+rax-0x20`


We can update our script to perform the above:

```python
import interact
import struct
import re

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('q', s)[0]

# Pack integer 'n' into a 4-Byte representation
def p32(n):
    return struct.pack('i', n)

# Unpack 4-Byte-long int 's' into a Python integer
def u32(s):
    return struct.unpack('i', s)[0]

p = interact.Process()
data = p.readuntil('RESPONSE:')
challenge_str = re.search("(?<=:\s).*(?=\\n)", data.decode('utf-8')).group(0)
challenge_ascii_list = [ord(x) for x in challenge_str]

#print(f'{data}\n')
print(f'Challenge String: {challenge_str}\n')

# First Segment
first_seg = 0
first_seg_list = []

for i in range(5):
    first_seg = first_seg << 7
    first_seg = ((challenge_ascii_list[i]) ^ first_seg)
    first_seg_list.append(hex(first_seg))

print(f'First Segment Computation: {first_seg_list}')

# Second Segment
second_seg = 0      # rbp+rax-0x40
block_2 = ""
block_3 = ""
block_4 = ""

for i in range(5):
    second_seg = ((challenge_ascii_list[i + 6]) ^ second_seg)
    block_2 += hex(second_seg)[2:].upper()
    print(f'Block_2_Iteration {i}: char {chr(challenge_ascii_list[i + 6])} ^ second_seg = {hex(second_seg)} --> Block_2 = 0x{block_2}')

    second_seg = ((challenge_ascii_list[i + 12]) ^ second_seg)
    block_3 += hex(second_seg)[2:].upper()
    print(f'Block_3_Iteration {i}: char {chr(challenge_ascii_list[i + 12])} ^ second_seg = {hex(second_seg)} --> Block_3 = 0x{block_3}')

    second_seg = ((challenge_ascii_list[i + 18]) ^ second_seg)
    block_4 += hex(second_seg)[2:].upper()
    print(f'Block_4_Iteration {i}: char {chr(challenge_ascii_list[i + 18])} ^ second_seg = {hex(second_seg)} --> Block_4 = 0x{block_4}')
    second_seg = 0


# Third Segment

third_seg = ""       # rbp+rax-0x20
num_1_list = [x for x in p64(0x49057d5b38f8)]  # rax+0x6020b0
num_2 = 0x4ec4ec4f
str_1 = []

for i in range(5):
    var_1 = (challenge_ascii_list[i + 24]) * num_1_list[i]
    print(f'var_1: {var_1} --- 4 Bytes: {hex(var_1)}')

    var_2 = p64((var_1 * num_2))    # needs to be 4bytes in size
    eax = u32(var_2[:4])     # Low Order Bits
    edx = u32(var_2[4:])   # High Order Bits
    print(f'var_2: {u64(var_2)} --- 4 Bytes: {hex(u64(var_2))}')
    print(f'var_2 EDX: {edx} --- 4 Bytes: {hex(edx)}')
    print(f'var_2 EAX: {eax} --- 4 Bytes: {hex(eax)}')
    edx = edx >> 3
    print(f'EDX >> 3 = {hex(edx)}')

    var_3 = var_1 >> 31
    print(f'var_3: {var_3} --- 4 Bytes: {hex(var_3)}')

    var_4 = (edx - var_3) * 26
    print(f'var_4: {var_4} --- 4 Bytes: {hex(var_4)}')

    var_5 = var_1 - var_4
    print(f'var_5: {var_5} --- 4 Bytes: {hex(var_5)}')
    str_1.append(p32(var_5)[0])

print([hex(x) for x in str_1])
for i in range(5):
    print(hex(p32(str_1[i] + 0x41)[0]))
    third_seg += chr(p32(str_1[i] + 0x41)[0])

RESP = f'{first_seg}/{block_4}/{third_seg}'
print(f'Sending: {RESP}')

p.sendline(RESP)
p.interactive()
```

