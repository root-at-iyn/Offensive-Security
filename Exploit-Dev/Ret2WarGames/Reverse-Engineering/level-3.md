# Reverse Engineering Level 3 -  Challenge / Response
 
### This was the 3rd and final challenge in the Reverse Engineering challenge from Ret2 WarGames :sweat_smile:

## The Mission

### Challenge / Response
Wow, stealing acquiring software is hard work... This one communicates with a server of some kind and makes you submit a ton of valid request-response pairs.

This is a tricky one, but we think you're ready for it.

## Static / Dynamic Analysis
 
Judging by the title, it looks like this level involves us producing a correct response to a challenge we are given. When the program starts, it prints a challenge to the console and asks the user for a Response input:

```bash
CHALLENGE: DLKZA-RQTTQ-SWIGA-TZDRM-QVVAG
RESPONSE:
```

If you supply some random data in the response field you will see the message `INCORRECT RESPONSE! (ERROR CODE 2)` and the program terminates. 

The first check point (hint) in the level says `"Produce the first segment of a valid response".` From this statement, we can infer that we should probably be looking into the disassembly for the `valid_response` function.

When you look at the disassembled function, you'll instantly notice that it is much larger than the previous two levels and feels quite intimidating.  


```asm

0x400b86:  push    rbp
0x400b87:  mov     rbp, rsp
0x400b8a:  sub     rsp, 0x70
0x400b8e:  mov     qword [rbp-0x68], rdi
0x400b92:  mov     qword [rbp-0x70], rsi
0x400b96:  mov     rax, qword [fs:0x28]
0x400b9f:  mov     qword [rbp-0x8], rax
0x400ba3:  xor     eax, eax
0x400ba5:  mov     dword [rbp-0x40], 0x0
0x400bac:  mov     byte [rbp-0x3c], 0x0
0x400bb0:  mov     qword [rbp-0x30], 0x0
0x400bb8:  mov     qword [rbp-0x28], 0x0
0x400bc0:  mov     qword [rbp-0x20], 0x0
0x400bc8:  mov     qword [rbp-0x18], 0x0
0x400bd0:  mov     dword [rbp-0x5c], 0x0
0x400bd7:  mov     dword [rbp-0x4c], 0x0
0x400bde:  mov     dword [rbp-0x58], 0x0
0x400be5:  jmp     0x400c02
0x400be7:  shl     dword [rbp-0x5c], 0x7
0x400beb:  mov     edx, dword [rbp-0x58]
0x400bee:  mov     rax, qword [rbp-0x68]
0x400bf2:  add     rax, rdx
0x400bf5:  movzx   eax, byte [rax]
0x400bf8:  movsx   eax, al
0x400bfb:  xor     dword [rbp-0x5c], eax
0x400bfe:  add     dword [rbp-0x58], 0x1
0x400c02:  cmp     dword [rbp-0x58], 0x4
0x400c06:  jbe     0x400be7
0x400c08:  mov     rax, qword [rbp-0x70]
0x400c0c:  mov     esi, 0x401018
0x400c11:  mov     rdi, rax
0x400c14:  call    strtok
0x400c19:  mov     qword [rbp-0x48], rax
0x400c1d:  cmp     qword [rbp-0x48], 0x0
0x400c22:  jne     0x400c2e
0x400c24:  mov     eax, 0x1
0x400c29:  jmp     0x400d83
0x400c2e:  mov     rax, qword [rbp-0x48]
0x400c32:  mov     rdi, rax
0x400c35:  call    atol
0x400c3a:  mov     dword [rbp-0x4c], eax
0x400c3d:  mov     eax, dword [rbp-0x4c]
0x400c40:  cmp     eax, dword [rbp-0x5c]
0x400c43:  je      0x400c4f
0x400c45:  mov     eax, 0x2
0x400c4a:  jmp     0x400d83
0x400c4f:  mov     dword [rbp-0x54], 0x0
0x400c56:  jmp     0x400cc5
0x400c58:  mov     eax, dword [rbp-0x54]
0x400c5b:  movzx   edx, byte [rbp+rax-0x40]
0x400c60:  mov     eax, dword [rbp-0x54]
0x400c63:  add     eax, 0x6
0x400c66:  mov     ecx, eax
0x400c68:  mov     rax, qword [rbp-0x68]
0x400c6c:  add     rax, rcx
0x400c6f:  movzx   eax, byte [rax]
0x400c72:  xor     edx, eax
0x400c74:  mov     eax, dword [rbp-0x54]
0x400c77:  mov     byte [rbp+rax-0x40], dl
0x400c7b:  mov     eax, dword [rbp-0x54]
0x400c7e:  movzx   edx, byte [rbp+rax-0x40]
0x400c83:  mov     eax, dword [rbp-0x54]
0x400c86:  add     eax, 0xc
0x400c89:  mov     ecx, eax
0x400c8b:  mov     rax, qword [rbp-0x68]
0x400c8f:  add     rax, rcx
0x400c92:  movzx   eax, byte [rax]
0x400c95:  xor     edx, eax
0x400c97:  mov     eax, dword [rbp-0x54]
0x400c9a:  mov     byte [rbp+rax-0x40], dl
0x400c9e:  mov     eax, dword [rbp-0x54]
0x400ca1:  movzx   edx, byte [rbp+rax-0x40]
0x400ca6:  mov     eax, dword [rbp-0x54]
0x400ca9:  add     eax, 0x12
0x400cac:  mov     ecx, eax
0x400cae:  mov     rax, qword [rbp-0x68]
0x400cb2:  add     rax, rcx
0x400cb5:  movzx   eax, byte [rax]
0x400cb8:  xor     edx, eax
0x400cba:  mov     eax, dword [rbp-0x54]
0x400cbd:  mov     byte [rbp+rax-0x40], dl
0x400cc1:  add     dword [rbp-0x54], 0x1
0x400cc5:  cmp     dword [rbp-0x54], 0x4
0x400cc9:  jbe     0x400c58
0x400ccb:  mov     dword [rbp-0x50], 0x0
0x400cd2:  jmp     0x400d06
0x400cd4:  mov     eax, dword [rbp-0x50]
0x400cd7:  movzx   eax, byte [rbp+rax-0x40]
0x400cdc:  movsx   eax, al
0x400cdf:  mov     edx, dword [rbp-0x50]
0x400ce2:  lea     ecx, [rdx+rdx]
0x400ce5:  lea     rdx, [rbp-0x30]
0x400ce9:  mov     ecx, ecx
0x400ceb:  add     rcx, rdx
0x400cee:  mov     edx, eax
0x400cf0:  mov     esi, 0x40101a {"%02X"
0x400cf5:  mov     rdi, rcx
0x400cf8:  mov     eax, 0x0
0x400cfd:  call    sprintf
0x400d02:  add     dword [rbp-0x50], 0x1
0x400d06:  cmp     dword [rbp-0x50], 0x4
0x400d0a:  jbe     0x400cd4
0x400d0c:  mov     esi, 0x401018
0x400d11:  mov     edi, 0x0
0x400d16:  call    strtok
0x400d1b:  mov     qword [rbp-0x48], rax
0x400d1f:  cmp     qword [rbp-0x48], 0x0
0x400d24:  jne     0x400d2d
0x400d26:  mov     eax, 0x3
0x400d2b:  jmp     0x400d83
0x400d2d:  lea     rdx, [rbp-0x30]
0x400d31:  mov     rax, qword [rbp-0x48]
0x400d35:  mov     rsi, rdx
0x400d38:  mov     rdi, rax
0x400d3b:  call    strcmp
0x400d40:  test    eax, eax
0x400d42:  je      0x400d4b
0x400d44:  mov     eax, 0x4
0x400d49:  jmp     0x400d83
0x400d4b:  mov     esi, 0x40101f
0x400d50:  mov     edi, 0x0
0x400d55:  call    strtok
0x400d5a:  mov     qword [rbp-0x48], rax
0x400d5e:  cmp     qword [rbp-0x48], 0x0
0x400d63:  jne     0x400d6c
0x400d65:  mov     eax, 0x5
0x400d6a:  jmp     0x400d83
0x400d6c:  mov     rax, qword [rbp-0x68]
0x400d70:  lea     rdx, [rax+0x18]
0x400d74:  mov     rax, qword [rbp-0x48]
0x400d78:  mov     rsi, rax
0x400d7b:  mov     rdi, rdx
0x400d7e:  call    validate_final
0x400d83:  mov     rsi, qword [rbp-0x8]
0x400d87:  xor     rsi, qword [fs:0x28]
0x400d90:  je      0x400d97
0x400d92:  call    __stack_chk_fail
0x400d97:  leave
0x400d98:  retn

```

That was 130 lines of Assembly output :astonished:

The first step is to break disassembled function into small pieces of logic. We know that we need to derive the the first segment of a valid response, so it makes sense to start with the first set of instrctions between `0x400b86` and `0x400be5`.

```asm
0x400b86:  push    rbp
0x400b87:  mov     rbp, rsp
0x400b8a:  sub     rsp, 0x70
0x400b8e:  mov     qword [rbp-0x68], rdi
0x400b92:  mov     qword [rbp-0x70], rsi
0x400b96:  mov     rax, qword [fs:0x28]
0x400b9f:  mov     qword [rbp-0x8], rax
0x400ba3:  xor     eax, eax
0x400ba5:  mov     dword [rbp-0x40], 0x0
0x400bac:  mov     byte [rbp-0x3c], 0x0
0x400bb0:  mov     qword [rbp-0x30], 0x0
0x400bb8:  mov     qword [rbp-0x28], 0x0
0x400bc0:  mov     qword [rbp-0x20], 0x0
0x400bc8:  mov     qword [rbp-0x18], 0x0
0x400bd0:  mov     dword [rbp-0x5c], 0x0
0x400bd7:  mov     dword [rbp-0x4c], 0x0
0x400bde:  mov     dword [rbp-0x58], 0x0
0x400be5:  jmp     0x400c02
```
The above instructions do the following: 

1. Setup the function prologue.
2. Move 2 arguments received by the function in `rdi` and `rsi` into memeory locations `rbp-0x68` and `rbp-0x70`
3. Get's a value from the `fs:0x28` and saves it to rax, then to memory location `rbp-0x8`
4. The remaining instructions up to `0x400be5` set some variables (memory locations) to 0 and then moves execution (`jmp`) to the next section of instructions begininning at `0x400c02`

### Segment 1

The section of instructions at `0x400c02` form the first loop of the program and some initial logic: 

```asm
0x400be7:  shl     dword [rbp-0x5c], 0x7
0x400beb:  mov     edx, dword [rbp-0x58]
0x400bee:  mov     rax, qword [rbp-0x68]
0x400bf2:  add     rax, rdx
0x400bf5:  movzx   eax, byte [rax]
0x400bf8:  movsx   eax, al
0x400bfb:  xor     dword [rbp-0x5c], eax
0x400bfe:  add     dword [rbp-0x58], 0x1
0x400c02:  cmp     dword [rbp-0x58], 0x4
0x400c06:  jbe     0x400be7
```

1. Shift the value in `rbp-0x5c` left by 7
2. Add the current loop iteration (`rbp-0x58`) and the pointer to the response entered by the user (`rbp-0x68`)
3. Get the most significant byte (`little endian`) from the previous result
4. XOR the current loop iteration and the byte from the previous result in `eax`
5. Add one to the current loop and repeat three more times
6. When the loop has completed 4 iterations, continue to the next set of instructions.


The next set of instructions between `0x400c08` and `0x400c29` completes the first segment of the program's logic. 

```asm
0x400c08:  mov     rax, qword [rbp-0x70]
0x400c0c:  mov     esi, 0x401018
0x400c11:  mov     rdi, rax
0x400c14:  call    strtok
0x400c19:  mov     qword [rbp-0x48], rax
0x400c1d:  cmp     qword [rbp-0x48], 0x0
0x400c22:  jne     0x400c2e
0x400c24:  mov     eax, 0x1
0x400c29:  jmp     0x400d83
```

The first 3 lines setup the call to the C function `strtok` which is used to break a string into a series of token using a delimeter.
The key component here is the `jne` at `0x400c22`. If `rbp-0x48` is not equal to zero, the program execution continues to `0x400c2e` and the next section of instructions will begin. 
However, if the comparison was equal, the program execution is directed to `0x400d83` which performs a stack cookie check to validate the stacks integrity.


