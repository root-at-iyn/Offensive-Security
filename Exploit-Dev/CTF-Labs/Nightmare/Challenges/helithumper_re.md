# Helithumper re

## Overview

Helithumper_re is the second chanllenge in the Beginner RE section of Nightmare. I attempted to solve it without reading the write up. 

When the binary runs you see the message: 

```bash
Welcome to the Salty Spitoon™, How tough are ya?
```

The terminal waits for some input, so just type some random characters to see what is says back:

```bash
liiiiiijio
```

After this we see the response:

```bash
Yeah right. Back to Weenie Hut Jr™ with ya 
```

## Reversing and solving the challenge

With gdb and GEF installed, my first stop is to take a look at the disassembly and then debug the binary.

```bash
gdb ./rev
disass main
```

We see the following:

```bash
Dump of assembler code for function main:
   0x0000000000001175 <+0>:     push   rbp
   0x0000000000001176 <+1>:     mov    rbp,rsp
   0x0000000000001179 <+4>:     sub    rsp,0x10
   0x000000000000117d <+8>:     mov    esi,0x1
   0x0000000000001182 <+13>:    mov    edi,0x32
   0x0000000000001187 <+18>:    call   0x1060 <calloc@plt>
   0x000000000000118c <+23>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000001190 <+27>:    lea    rdi,[rip+0xe71]        # 0x2008
   0x0000000000001197 <+34>:    call   0x1030 <puts@plt>
   0x000000000000119c <+39>:    mov    rax,QWORD PTR [rbp-0x8]
   0x00000000000011a0 <+43>:    mov    rsi,rax
   0x00000000000011a3 <+46>:    lea    rdi,[rip+0xe91]        # 0x203b
   0x00000000000011aa <+53>:    mov    eax,0x0
   0x00000000000011af <+58>:    call   0x1070 <__isoc99_scanf@plt>
   0x00000000000011b4 <+63>:    mov    rax,QWORD PTR [rbp-0x8]
   0x00000000000011b8 <+67>:    mov    rdi,rax
   0x00000000000011bb <+70>:    call   0x11ea <validate>
   0x00000000000011c0 <+75>:    test   eax,eax
   0x00000000000011c2 <+77>:    je     0x11d7 <main+98>
   0x00000000000011c4 <+79>:    lea    rdi,[rip+0xe73]        # 0x203e
   0x00000000000011cb <+86>:    call   0x1030 <puts@plt>
   0x00000000000011d0 <+91>:    mov    eax,0x0
   0x00000000000011d5 <+96>:    jmp    0x11e8 <main+115>
   0x00000000000011d7 <+98>:    lea    rdi,[rip+0xe72]        # 0x2050
   0x00000000000011de <+105>:   call   0x1030 <puts@plt>
   0x00000000000011e3 <+110>:   mov    eax,0x1
   0x00000000000011e8 <+115>:   leave
   0x00000000000011e9 <+116>:   ret
End of assembler dump.
```

The main things to note in the disassembly is:

1. A call is made to calloc with 2 arguments on the stack in reverse order before the call is made. The arguments are 0x32 and 0x1. The man page states calloc takes two arguments `size_t nelem` and `size_t elsize`. This translates to the first argument specifying the desired number of elements for the array, and the second argument specifying the size of each element in the array. So from this we can gather that an array of 50 bytes is allocated on the heap.
2. The result of the call to calloc is a pointer to the memory region and this is saved in rax. The pointer is copied to the stack at rbp-0x8 and passed in as an argument to the call made to scanf. Scanf reads input from the standard input stream, which means this is where our input will end up.
3. There is a call to another function `validate`. Immediately after the call there is a `test eax, eax` instruction. This instuction performs a bitwise AND on eax which holds the result of the call to valdiate. This is a comparision check. If the result is zero execution is directed to `0x11d7` where somthing is output to the screen and the main function returns `0x1` in eax.

Judging from this, the input from scanf is sent to validate where a comparison is probably performed and the result of that is returned to main. The comparison is likely to be a check for the flag against whatever input we have sent. Now we need to disassemble validate to check if the thoery is correct.

```bash
gef➤  disass validate
Dump of assembler code for function validate:
   0x00000000000011ea <+0>:     push   rbp
   0x00000000000011eb <+1>:     mov    rbp,rsp
   0x00000000000011ee <+4>:     sub    rsp,0x60
   0x00000000000011f2 <+8>:     mov    QWORD PTR [rbp-0x58],rdi
   0x00000000000011f6 <+12>:    mov    rax,QWORD PTR fs:0x28
   0x00000000000011ff <+21>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000001203 <+25>:    xor    eax,eax
   0x0000000000001205 <+27>:    mov    DWORD PTR [rbp-0x40],0x66
   0x000000000000120c <+34>:    mov    DWORD PTR [rbp-0x3c],0x6c
   0x0000000000001213 <+41>:    mov    DWORD PTR [rbp-0x38],0x61
   0x000000000000121a <+48>:    mov    DWORD PTR [rbp-0x34],0x67
   0x0000000000001221 <+55>:    mov    DWORD PTR [rbp-0x30],0x7b
   0x0000000000001228 <+62>:    mov    DWORD PTR [rbp-0x2c],0x48
   0x000000000000122f <+69>:    mov    DWORD PTR [rbp-0x28],0x75
   0x0000000000001236 <+76>:    mov    DWORD PTR [rbp-0x24],0x43
   0x000000000000123d <+83>:    mov    DWORD PTR [rbp-0x20],0x66
   0x0000000000001244 <+90>:    mov    DWORD PTR [rbp-0x1c],0x5f
   0x000000000000124b <+97>:    mov    DWORD PTR [rbp-0x18],0x6c
   0x0000000000001252 <+104>:   mov    DWORD PTR [rbp-0x14],0x41
   0x0000000000001259 <+111>:   mov    DWORD PTR [rbp-0x10],0x62
   0x0000000000001260 <+118>:   mov    DWORD PTR [rbp-0xc],0x7d
   0x0000000000001267 <+125>:   mov    rax,QWORD PTR [rbp-0x58]
   0x000000000000126b <+129>:   mov    rdi,rax
   0x000000000000126e <+132>:   call   0x1040 <strlen@plt>
   0x0000000000001273 <+137>:   mov    DWORD PTR [rbp-0x44],eax
   0x0000000000001276 <+140>:   mov    DWORD PTR [rbp-0x48],0x0
   0x000000000000127d <+147>:   jmp    0x12aa <validate+192>
   0x000000000000127f <+149>:   mov    eax,DWORD PTR [rbp-0x48]
   0x0000000000001282 <+152>:   movsxd rdx,eax
   0x0000000000001285 <+155>:   mov    rax,QWORD PTR [rbp-0x58]
   0x0000000000001289 <+159>:   add    rax,rdx
   0x000000000000128c <+162>:   movzx  eax,BYTE PTR [rax]
   0x000000000000128f <+165>:   movsx  edx,al
   0x0000000000001292 <+168>:   mov    eax,DWORD PTR [rbp-0x48]
   0x0000000000001295 <+171>:   cdqe
   0x0000000000001297 <+173>:   mov    eax,DWORD PTR [rbp+rax*4-0x40]
   0x000000000000129b <+177>:   cmp    edx,eax
   0x000000000000129d <+179>:   je     0x12a6 <validate+188>
   0x000000000000129f <+181>:   mov    eax,0x0
   0x00000000000012a4 <+186>:   jmp    0x12b7 <validate+205>
   0x00000000000012a6 <+188>:   add    DWORD PTR [rbp-0x48],0x1
   0x00000000000012aa <+192>:   mov    eax,DWORD PTR [rbp-0x48]
   0x00000000000012ad <+195>:   cmp    eax,DWORD PTR [rbp-0x44]
   0x00000000000012b0 <+198>:   jl     0x127f <validate+149>
   0x00000000000012b2 <+200>:   mov    eax,0x1
   0x00000000000012b7 <+205>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x00000000000012bb <+209>:   xor    rcx,QWORD PTR fs:0x28
   0x00000000000012c4 <+218>:   je     0x12cb <validate+225>
   0x00000000000012c6 <+220>:   call   0x1050 <__stack_chk_fail@plt>
   0x00000000000012cb <+225>:   leave
   0x00000000000012cc <+226>:   ret
End of assembler dump.
```

From the output, we see the validate function moves a series of 1 byte characters to memory regions between rbp-0xc and rbp-0x40. The bytes we sent from scanf in main are sent as an arg in rdi and then saved into rbp-0x58. further down in the disassembly each byte of our input is compared with the corresponding byte sequence of the 1 byte characters we saw previously (rbp-0xc to rbp-0x58). If each compared byte is equal, 0x1 will be returned in eax and the function will return to main.

To solve the challenge we can run the programmer through the debugger and inspect the values stored in memory that the scanf input is being compared to. This should produce a string. We'll examine the memory in gdb for ascii strings, then copy the output to a file.

### Copy memory dump

examine the memory region and copy the output to a file "flag.txt".

```bash
gef➤  x/60s 0x00007fffffffdf60
0x7fffffffdf60:    "f"
0x7fffffffdf62:    ""
0x7fffffffdf63:    ""
0x7fffffffdf64:    "l"
0x7fffffffdf66:    ""
0x7fffffffdf67:    ""
0x7fffffffdf68:    "a"
0x7fffffffdf6a:    ""
0x7fffffffdf6b:    ""
0x7fffffffdf6c:    "g"
0x7fffffffdf6e:    ""
0x7fffffffdf6f:    ""
0x7fffffffdf70:    "{"
0x7fffffffdf72:    ""
0x7fffffffdf73:    ""
0x7fffffffdf74:    "H"
0x7fffffffdf76:    ""
0x7fffffffdf77:    ""
0x7fffffffdf78:    "u"
0x7fffffffdf7a:    ""
0x7fffffffdf7b:    ""
0x7fffffffdf7c:    "C"
0x7fffffffdf7e:    ""
0x7fffffffdf7f:    ""
0x7fffffffdf80:    "f"
0x7fffffffdf82:    ""
0x7fffffffdf83:    ""
0x7fffffffdf84:    "_"
0x7fffffffdf86:    ""
0x7fffffffdf87:    ""
0x7fffffffdf88:    "l"
0x7fffffffdf8a:    ""
0x7fffffffdf8b:    ""
0x7fffffffdf8c:    "A"
0x7fffffffdf8e:    ""
0x7fffffffdf8f:    ""
0x7fffffffdf90:    "b"
0x7fffffffdf92:    ""
0x7fffffffdf93:    ""
0x7fffffffdf94:    "}"
```

### Bash command to clean flag copied from memory dump

```bash
cat flag.txt | cut -f2 | cut -c 2 | sed 's/"//' | sed '/^$/d' | awk '{print}' ORS=''
```

The flag should now be cleaned and displayed in one line in the terminal.

```bash
flag{HuCf_lAb}
```
